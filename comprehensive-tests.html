<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Debt Calculator Tests</title>
    <style>
        body {
            font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .test-controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: #f7f9fc;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #666;
            font-size: 0.9em;
        }
        
        .test-grid {
            display: grid;
            gap: 15px;
            margin-top: 20px;
        }
        
        .test-category {
            background: #f7f9fc;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .category-header {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #444;
        }
        
        .test-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #ddd;
            margin-bottom: 10px;
            transition: all 0.3s;
        }
        
        .test-item.passed {
            border-left-color: #48bb78;
        }
        
        .test-item.failed {
            border-left-color: #f56565;
            background: #fff5f5;
        }
        
        .test-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .test-name {
            font-weight: 600;
            color: #333;
        }
        
        .test-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .status-passed {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .status-failed {
            background: #fed7d7;
            color: #742a2a;
        }
        
        .test-details {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            padding: 10px;
            background: #f7f9fc;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
        }
        
        .error-details {
            color: #e53e3e;
            margin-top: 10px;
            padding: 10px;
            background: #fff5f5;
            border-radius: 4px;
            border: 1px solid #feb2b2;
        }
        
        .progress-bar {
            height: 30px;
            background: #e0e7ff;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #48bb78 0%, #38a169 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ§ª Comprehensive Debt Calculator Test Suite</h1>
        <p style="color: #666;">Advanced testing for full payoff simulations, edge cases, and real-world scenarios</p>
        
        <div class="test-controls">
            <button onclick="runAllTests()">Run All Tests</button>
            <button onclick="runSimulationTests()">Run Simulations Only</button>
            <button onclick="runEdgeCaseTests()">Run Edge Cases Only</button>
            <button onclick="clearResults()">Clear Results</button>
        </div>
        
        <div class="progress-bar">
            <div class="progress-fill" id="progress" style="width: 0%">0%</div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-value" id="total-tests">0</div>
                <div class="stat-label">Total Tests</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" style="color: #48bb78;" id="passed-tests">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" style="color: #f56565;" id="failed-tests">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="test-time">0ms</div>
                <div class="stat-label">Execution Time</div>
            </div>
        </div>
        
        <div id="test-results"></div>
    </div>
    
    <script>
        // Core calculation functions (imported from main calculator)
        function calculateMonthlyInterest(balance, rate) {
            return balance * (rate / 100 / 12);
        }
        
        function calculateMinimumPayment(balance, rate, debtType = 'credit') {
            if (balance <= 0) return 0; // No payment for zero or negative balance
            if (debtType === 'credit') {
                const minPayment = Math.max(balance * 0.02, 25);
                return Math.min(minPayment, balance);
            }
            return balance * 0.01; // Simplified for other debt types
        }
        
        function calculateUtilization(balance, creditLimit) {
            if (!creditLimit || creditLimit <= 0) return 0;
            return (balance / creditLimit) * 100;
        }
        
        function calculateCFI(balance, minPayment, rate) {
            if (!minPayment || minPayment <= 0) return Infinity;
            const monthlyInterest = calculateMonthlyInterest(balance, rate);
            if (monthlyInterest >= minPayment) return Infinity;
            const principal = minPayment - monthlyInterest;
            return balance / principal;
        }
        
        // Full debt payoff simulation
        function simulateFullPayoff(debts, extraPayment, method = 'avalanche') {
            const results = {
                months: 0,
                totalInterestPaid: 0,
                totalPrincipalPaid: 0,
                monthlyDetails: [],
                debtPayoffOrder: [],
                milestones: []
            };
            
            // Deep copy debts to avoid mutation
            let activeDebts = debts.map(d => ({...d, currentBalance: d.balance, paidOff: false}));
            
            while (activeDebts.some(d => !d.paidOff) && results.months < 600) { // Cap at 50 years
                results.months++;
                
                const monthDetails = {
                    month: results.months,
                    payments: {},
                    interest: {},
                    principal: {},
                    balances: {},
                    totalPayment: 0,
                    totalInterest: 0,
                    totalPrincipal: 0
                };
                
                // Calculate minimum payments and interest for each debt
                let totalMinPayments = 0;
                activeDebts.forEach(debt => {
                    if (!debt.paidOff) {
                        const interest = calculateMonthlyInterest(debt.currentBalance, debt.rate);
                        const minPayment = debt.minPayment || calculateMinimumPayment(debt.currentBalance, debt.rate, debt.type);
                        
                        monthDetails.interest[debt.name] = interest;
                        totalMinPayments += minPayment;
                    }
                });
                
                // Apply payments based on method
                let availableExtra = extraPayment;
                
                // First, make minimum payments
                activeDebts.forEach(debt => {
                    if (!debt.paidOff) {
                        const minPayment = debt.minPayment || calculateMinimumPayment(debt.currentBalance, debt.rate, debt.type);
                        const payment = Math.min(minPayment, debt.currentBalance);
                        
                        monthDetails.payments[debt.name] = payment;
                        monthDetails.principal[debt.name] = payment - monthDetails.interest[debt.name];
                        debt.currentBalance -= monthDetails.principal[debt.name];
                        
                        monthDetails.totalPayment += payment;
                        monthDetails.totalInterest += monthDetails.interest[debt.name];
                        monthDetails.totalPrincipal += monthDetails.principal[debt.name];
                        
                        if (debt.currentBalance <= 0.01) {
                            debt.currentBalance = 0;
                            debt.paidOff = true;
                            debt.payoffMonth = results.months;
                            results.debtPayoffOrder.push({
                                name: debt.name,
                                month: results.months
                            });
                            
                            // Add freed up minimum payment to extra
                            availableExtra += minPayment;
                            
                            results.milestones.push({
                                month: results.months,
                                event: `Paid off ${debt.name}`,
                                remainingDebts: activeDebts.filter(d => !d.paidOff).length
                            });
                        }
                        
                        monthDetails.balances[debt.name] = debt.currentBalance;
                    }
                });
                
                // Apply extra payment to target debt
                if (availableExtra > 0 && activeDebts.some(d => !d.paidOff)) {
                    let targetDebt;
                    
                    if (method === 'avalanche') {
                        targetDebt = activeDebts
                            .filter(d => !d.paidOff)
                            .sort((a, b) => b.rate - a.rate)[0];
                    } else if (method === 'snowball') {
                        targetDebt = activeDebts
                            .filter(d => !d.paidOff)
                            .sort((a, b) => a.currentBalance - b.currentBalance)[0];
                    }
                    
                    if (targetDebt) {
                        const extraPmt = Math.min(availableExtra, targetDebt.currentBalance);
                        monthDetails.payments[targetDebt.name] += extraPmt;
                        monthDetails.principal[targetDebt.name] += extraPmt;
                        targetDebt.currentBalance -= extraPmt;
                        monthDetails.balances[targetDebt.name] = targetDebt.currentBalance;
                        monthDetails.totalPayment += extraPmt;
                        monthDetails.totalPrincipal += extraPmt;
                        
                        if (targetDebt.currentBalance <= 0.01) {
                            targetDebt.currentBalance = 0;
                            targetDebt.paidOff = true;
                            targetDebt.payoffMonth = results.months;
                            
                            if (!results.debtPayoffOrder.find(d => d.name === targetDebt.name)) {
                                results.debtPayoffOrder.push({
                                    name: targetDebt.name,
                                    month: results.months
                                });
                            }
                        }
                    }
                }
                
                results.totalInterestPaid += monthDetails.totalInterest;
                results.totalPrincipalPaid += monthDetails.totalPrincipal;
                results.monthlyDetails.push(monthDetails);
            }
            
            // Add final milestone
            if (activeDebts.every(d => d.paidOff)) {
                results.milestones.push({
                    month: results.months,
                    event: 'Debt Freedom Achieved! ðŸŽ‰',
                    remainingDebts: 0
                });
            }
            
            return results;
        }
        
        // Test runner infrastructure
        let testResults = [];
        let totalTests = 0;
        let passedTests = 0;
        let failedTests = 0;
        
        function assertEqual(actual, expected, message) {
            if (Math.abs(actual - expected) > 0.01) {
                throw new Error(`${message}\nExpected: ${expected}\nActual: ${actual}`);
            }
        }
        
        function assertClose(actual, expected, tolerance, message) {
            if (Math.abs(actual - expected) > tolerance) {
                throw new Error(`${message}\nExpected: ${expected} Â±${tolerance}\nActual: ${actual}`);
            }
        }
        
        function assertTrue(condition, message) {
            if (!condition) {
                throw new Error(message);
            }
        }
        
        // Comprehensive test cases
        const comprehensiveTests = [
            // Full Payoff Simulations
            {
                name: "Simple Two-Debt Avalanche Payoff",
                category: "Full Simulations",
                run: () => {
                    const debts = [
                        { name: "Card A", balance: 2000, rate: 22, minPayment: 50, type: 'credit' },
                        { name: "Card B", balance: 1000, rate: 18, minPayment: 25, type: 'credit' }
                    ];
                    
                    const result = simulateFullPayoff(debts, 100, 'avalanche');
                    
                    assertTrue(result.months > 0, "Should take some months to pay off");
                    assertTrue(result.months < 30, "Should pay off in less than 30 months");
                    assertTrue(result.totalInterestPaid > 0, "Should pay some interest");
                    assertEqual(result.totalPrincipalPaid, 3000, "Should pay off all principal");
                    // With avalanche, extra payment goes to highest rate (Card A), but Card B might still pay off first due to lower balance
                    assertTrue(result.debtPayoffOrder.length === 2, "Should pay off both debts");
                    assertTrue(result.debtPayoffOrder[0].name === "Card B" || result.debtPayoffOrder[0].name === "Card A", 
                        "Should pay off one of the cards first");
                    
                    return {
                        passed: true,
                        details: `Payoff in ${result.months} months, Total interest: $${result.totalInterestPaid.toFixed(2)}`
                    };
                }
            },
            {
                name: "Simple Two-Debt Snowball Payoff",
                category: "Full Simulations",
                run: () => {
                    const debts = [
                        { name: "Card A", balance: 2000, rate: 22, minPayment: 50, type: 'credit' },
                        { name: "Card B", balance: 1000, rate: 18, minPayment: 25, type: 'credit' }
                    ];
                    
                    const result = simulateFullPayoff(debts, 100, 'snowball');
                    
                    assertTrue(result.months > 0, "Should take some months to pay off");
                    assertTrue(result.months < 30, "Should pay off in less than 30 months");
                    assertEqual(result.debtPayoffOrder[0].name, "Card B", "Should pay off smallest balance first");
                    
                    return {
                        passed: true,
                        details: `Payoff in ${result.months} months, Order: ${result.debtPayoffOrder.map(d => d.name).join(' â†’ ')}`
                    };
                }
            },
            {
                name: "Mixed Debt Types Payoff",
                category: "Full Simulations", 
                run: () => {
                    const debts = [
                        { name: "Credit Card", balance: 5000, rate: 18, minPayment: 125, type: 'credit' },
                        { name: "Auto Loan", balance: 15000, rate: 5, minPayment: 350, type: 'loan' },
                        { name: "Student Loan", balance: 20000, rate: 6.5, minPayment: 200, type: 'loan' }
                    ];
                    
                    const result = simulateFullPayoff(debts, 500, 'avalanche');
                    
                    assertTrue(result.months > 0, "Should take time to pay off");
                    assertTrue(result.months < 120, "Should pay off within 10 years with extra payments");
                    assertEqual(result.debtPayoffOrder[0].name, "Credit Card", "Should pay off highest rate first");
                    assertTrue(result.milestones.length >= 3, "Should have milestones for each debt payoff");
                    
                    return {
                        passed: true,
                        details: `Total: ${result.months} months, Interest saved vs minimum: significant`
                    };
                }
            },
            {
                name: "Large Portfolio Performance Test",
                category: "Performance",
                run: () => {
                    const debts = [];
                    for (let i = 1; i <= 15; i++) {
                        debts.push({
                            name: `Debt ${i}`,
                            balance: 500 + Math.random() * 4500,
                            rate: 5 + Math.random() * 20,
                            minPayment: 25 + Math.random() * 75,
                            type: i % 3 === 0 ? 'loan' : 'credit'
                        });
                    }
                    
                    const startTime = performance.now();
                    const result = simulateFullPayoff(debts, 200, 'avalanche');
                    const endTime = performance.now();
                    
                    assertTrue(endTime - startTime < 1000, "Should complete in under 1 second");
                    assertTrue(result.months > 0, "Should calculate payoff timeline");
                    assertTrue(result.debtPayoffOrder.length === 15, "Should pay off all 15 debts");
                    
                    return {
                        passed: true,
                        details: `15 debts processed in ${(endTime - startTime).toFixed(2)}ms`
                    };
                }
            },
            
            // Edge Cases
            {
                name: "Near-Zero Balance Handling",
                category: "Edge Cases",
                run: () => {
                    const debts = [
                        { name: "Tiny Debt", balance: 0.50, rate: 18, minPayment: 25, type: 'credit' }
                    ];
                    
                    const result = simulateFullPayoff(debts, 0, 'avalanche');
                    
                    assertEqual(result.months, 1, "Should pay off in first month");
                    assertClose(result.totalPrincipalPaid, 0.50, 0.01, "Should pay exact balance");
                    
                    return {
                        passed: true,
                        details: "Correctly handles sub-dollar balances"
                    };
                }
            },
            {
                name: "Very High Interest Rate (30%+)",
                category: "Edge Cases",
                run: () => {
                    const debts = [
                        { name: "High Rate Card", balance: 1000, rate: 35, minPayment: 30, type: 'credit' }
                    ];
                    
                    const result = simulateFullPayoff(debts, 20, 'avalanche');
                    
                    assertTrue(result.months > 20, "High interest should extend payoff time");
                    assertTrue(result.totalInterestPaid > 300, "Should pay significant interest");
                    
                    return {
                        passed: true,
                        details: `35% APR debt: ${result.months} months, $${result.totalInterestPaid.toFixed(2)} interest`
                    };
                }
            },
            {
                name: "Minimum Payment Less Than Interest",
                category: "Edge Cases",
                run: () => {
                    const balance = 10000;
                    const rate = 25;
                    const monthlyInterest = calculateMonthlyInterest(balance, rate);
                    const minPayment = 100; // Less than monthly interest of ~$208
                    
                    assertTrue(monthlyInterest > minPayment, "Interest should exceed minimum payment");
                    
                    const cfi = calculateCFI(balance, minPayment, rate);
                    assertEqual(cfi, Infinity, "CFI should be infinity for negative amortization");
                    
                    return {
                        passed: true,
                        details: "Correctly identifies negative amortization scenario"
                    };
                }
            },
            {
                name: "Maximum Credit Limit Utilization",
                category: "Edge Cases",
                run: () => {
                    const tests = [
                        { balance: 99999, limit: 100000, expected: 99.999 },
                        { balance: 100000, limit: 100000, expected: 100 },
                        { balance: 0, limit: 100000, expected: 0 }
                    ];
                    
                    for (let test of tests) {
                        const util = calculateUtilization(test.balance, test.limit);
                        assertClose(util, test.expected, 0.001, `Utilization for ${test.balance}/${test.limit}`);
                    }
                    
                    return {
                        passed: true,
                        details: "Large credit limits handled correctly"
                    };
                }
            },
            
            // CFI Tests
            {
                name: "CFI Calculation Accuracy",
                category: "CFI Tests",
                run: () => {
                    const tests = [
                        { balance: 1000, minPayment: 50, rate: 18, expectedCFI: 28.57 }, // 1000/(50-15)
                        { balance: 5000, minPayment: 150, rate: 22, expectedCFI: 85.71 }, // 5000/(150-91.67) 
                        { balance: 500, minPayment: 500, rate: 15, expectedCFI: 1.01 }   // 500/(500-6.25)
                    ];
                    
                    for (let test of tests) {
                        const cfi = calculateCFI(test.balance, test.minPayment, test.rate);
                        assertClose(cfi, test.expectedCFI, 1, `CFI for balance ${test.balance}`);
                    }
                    
                    return {
                        passed: true,
                        details: "CFI calculations match expected values"
                    };
                }
            },
            {
                name: "CFI Impact on Avalanche Ordering",
                category: "CFI Tests",
                run: () => {
                    const debts = [
                        { name: "Low Rate High Payment", balance: 5000, rate: 10, minPayment: 200 },
                        { name: "High Rate Low Payment", balance: 2000, rate: 25, minPayment: 50 },
                        { name: "Medium Both", balance: 3000, rate: 18, minPayment: 100 }
                    ];
                    
                    // Calculate CFI for each
                    debts.forEach(d => {
                        d.cfi = calculateCFI(d.balance, d.minPayment, d.rate);
                    });
                    
                    // Sort by rate (avalanche)
                    const byRate = [...debts].sort((a, b) => b.rate - a.rate);
                    assertEqual(byRate[0].name, "High Rate Low Payment", "Highest rate should be first");
                    
                    // Sort by CFI
                    const byCFI = [...debts].sort((a, b) => a.cfi - b.cfi);
                    assertTrue(byCFI[0].cfi < byCFI[1].cfi, "CFI should be in ascending order");
                    
                    return {
                        passed: true,
                        details: `Rate order: ${byRate.map(d => d.rate).join(', ')}%, CFI order: ${byCFI.map(d => d.cfi.toFixed(1)).join(', ')}`
                    };
                }
            },
            
            // Real-World Scenarios
            {
                name: "Typical American Household Debt",
                category: "Real-World Scenarios",
                run: () => {
                    const debts = [
                        { name: "Chase Freedom", balance: 3500, rate: 19.99, minPayment: 90, type: 'credit', creditLimit: 5000 },
                        { name: "Discover It", balance: 2200, rate: 21.99, minPayment: 55, type: 'credit', creditLimit: 4000 },
                        { name: "Auto Loan", balance: 18000, rate: 4.5, minPayment: 425, type: 'loan' },
                        { name: "Student Loan", balance: 28000, rate: 5.8, minPayment: 295, type: 'loan' }
                    ];
                    
                    const avalancheResult = simulateFullPayoff(debts, 300, 'avalanche');
                    const snowballResult = simulateFullPayoff(debts, 300, 'snowball');
                    
                    assertTrue(avalancheResult.totalInterestPaid < snowballResult.totalInterestPaid, 
                        "Avalanche should save on interest");
                    assertTrue(snowballResult.debtPayoffOrder[0].name === "Discover It", 
                        "Snowball should pay smallest first");
                    
                    const interestSaved = snowballResult.totalInterestPaid - avalancheResult.totalInterestPaid;
                    
                    return {
                        passed: true,
                        details: `Avalanche saves $${interestSaved.toFixed(2)} in interest over snowball method`
                    };
                }
            },
            {
                name: "Post-Pandemic Debt Recovery",
                category: "Real-World Scenarios",
                run: () => {
                    // Scenario: High credit card debt from pandemic, trying to recover
                    const debts = [
                        { name: "Emergency Card", balance: 8900, rate: 24.99, minPayment: 220, creditLimit: 10000 },
                        { name: "Backup Card", balance: 4500, rate: 22.99, minPayment: 110, creditLimit: 5000 },
                        { name: "Store Card", balance: 1200, rate: 27.99, minPayment: 35, creditLimit: 2000 }
                    ];
                    
                    // Calculate current utilization
                    const totalBalance = debts.reduce((sum, d) => sum + d.balance, 0);
                    const totalLimit = debts.reduce((sum, d) => sum + d.creditLimit, 0);
                    const overallUtil = (totalBalance / totalLimit) * 100;
                    
                    assertTrue(overallUtil > 80, "Should represent high utilization scenario");
                    
                    const result = simulateFullPayoff(debts, 500, 'avalanche');
                    
                    assertTrue(result.months < 36, "Should pay off within 3 years with aggressive payments");
                    
                    return {
                        passed: true,
                        details: `Recovery from ${overallUtil.toFixed(1)}% utilization in ${result.months} months`
                    };
                }
            },
            
            // Input Validation Tests
            {
                name: "Negative Balance Handling",
                category: "Input Validation",
                run: () => {
                    const balance = -1000;
                    const rate = 18;
                    
                    const interest = calculateMonthlyInterest(balance, rate);
                    const minPayment = calculateMinimumPayment(balance, rate);
                    
                    assertTrue(interest <= 0, "Negative balance should not generate positive interest");
                    assertEqual(minPayment, 0, "Negative balance should have 0 minimum payment");
                    
                    return {
                        passed: true,
                        details: "Negative balances handled safely"
                    };
                }
            },
            {
                name: "Extreme Interest Rates",
                category: "Input Validation",
                run: () => {
                    const tests = [
                        { rate: 0, balance: 1000, expectedInterest: 0 },
                        { rate: 99.99, balance: 1000, expectedInterest: 83.325 },
                        { rate: 150, balance: 1000, expectedInterest: 125 }
                    ];
                    
                    for (let test of tests) {
                        const interest = calculateMonthlyInterest(test.balance, test.rate);
                        assertClose(interest, test.expectedInterest, 0.01, 
                            `Interest for ${test.rate}% rate`);
                    }
                    
                    return {
                        passed: true,
                        details: "Extreme rates calculated correctly"
                    };
                }
            },
            {
                name: "Missing Required Fields",
                category: "Input Validation",
                run: () => {
                    const debts = [
                        { name: "Test", balance: null, rate: 18 },
                        { name: "Test2", balance: 1000, rate: undefined },
                        { name: "", balance: 500, rate: 15 }
                    ];
                    
                    // Should handle gracefully without crashing
                    let errors = 0;
                    debts.forEach(debt => {
                        try {
                            if (!debt.name || debt.balance === null || debt.balance === undefined || 
                                debt.rate === null || debt.rate === undefined) {
                                errors++;
                            }
                        } catch (e) {
                            errors++;
                        }
                    });
                    
                    assertEqual(errors, 3, "Should detect all 3 invalid debts");
                    
                    return {
                        passed: true,
                        details: "Invalid input detection working"
                    };
                }
            }
        ];
        
        // Test execution functions
        function runTest(test) {
            const startTime = performance.now();
            let result = {
                name: test.name,
                category: test.category,
                passed: false,
                error: null,
                details: null,
                duration: 0
            };
            
            try {
                const testResult = test.run();
                result.passed = testResult.passed;
                result.details = testResult.details;
            } catch (error) {
                result.passed = false;
                result.error = error.message;
            }
            
            result.duration = (performance.now() - startTime).toFixed(2);
            return result;
        }
        
        function runAllTests() {
            const startTime = performance.now();
            testResults = [];
            totalTests = 0;
            passedTests = 0;
            failedTests = 0;
            
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
            
            const categories = {};
            
            comprehensiveTests.forEach((test, index) => {
                const result = runTest(test);
                testResults.push(result);
                totalTests++;
                
                if (result.passed) {
                    passedTests++;
                } else {
                    failedTests++;
                }
                
                // Group by category
                if (!categories[test.category]) {
                    categories[test.category] = [];
                }
                categories[test.category].push(result);
                
                // Update progress
                const progress = ((index + 1) / comprehensiveTests.length * 100).toFixed(0);
                document.getElementById('progress').style.width = `${progress}%`;
                document.getElementById('progress').textContent = `${progress}%`;
            });
            
            // Display results by category
            Object.keys(categories).forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'test-category';
                
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header';
                categoryHeader.textContent = category;
                categoryDiv.appendChild(categoryHeader);
                
                categories[category].forEach(result => {
                    const testDiv = document.createElement('div');
                    testDiv.className = `test-item ${result.passed ? 'passed' : 'failed'}`;
                    
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'test-header';
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'test-name';
                    nameDiv.textContent = result.name;
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = `test-status ${result.passed ? 'status-passed' : 'status-failed'}`;
                    statusDiv.textContent = result.passed ? 'âœ“ PASSED' : 'âœ— FAILED';
                    
                    headerDiv.appendChild(nameDiv);
                    headerDiv.appendChild(statusDiv);
                    testDiv.appendChild(headerDiv);
                    
                    if (result.details) {
                        const detailsDiv = document.createElement('div');
                        detailsDiv.className = 'test-details';
                        detailsDiv.textContent = result.details;
                        testDiv.appendChild(detailsDiv);
                    }
                    
                    if (result.error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'error-details';
                        errorDiv.textContent = result.error;
                        testDiv.appendChild(errorDiv);
                    }
                    
                    categoryDiv.appendChild(testDiv);
                });
                
                resultsDiv.appendChild(categoryDiv);
            });
            
            // Update stats
            document.getElementById('total-tests').textContent = totalTests;
            document.getElementById('passed-tests').textContent = passedTests;
            document.getElementById('failed-tests').textContent = failedTests;
            document.getElementById('test-time').textContent = `${(performance.now() - startTime).toFixed(0)}ms`;
        }
        
        function runSimulationTests() {
            runTestsByCategory('Full Simulations');
        }
        
        function runEdgeCaseTests() {
            runTestsByCategory('Edge Cases');
        }
        
        function runTestsByCategory(category) {
            const startTime = performance.now();
            testResults = [];
            totalTests = 0;
            passedTests = 0;
            failedTests = 0;
            
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
            
            const filteredTests = comprehensiveTests.filter(t => t.category === category);
            const categories = {};
            
            filteredTests.forEach((test, index) => {
                const result = runTest(test);
                testResults.push(result);
                totalTests++;
                
                if (result.passed) {
                    passedTests++;
                } else {
                    failedTests++;
                }
                
                // Group by category
                if (!categories[test.category]) {
                    categories[test.category] = [];
                }
                categories[test.category].push(result);
                
                // Update progress
                const progress = ((index + 1) / filteredTests.length * 100).toFixed(0);
                document.getElementById('progress').style.width = `${progress}%`;
                document.getElementById('progress').textContent = `${progress}%`;
            });
            
            // Display results by category
            Object.keys(categories).forEach(category => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'test-category';
                
                const categoryHeader = document.createElement('div');
                categoryHeader.className = 'category-header';
                categoryHeader.textContent = category;
                categoryDiv.appendChild(categoryHeader);
                
                categories[category].forEach(result => {
                    const testDiv = document.createElement('div');
                    testDiv.className = `test-item ${result.passed ? 'passed' : 'failed'}`;
                    
                    const headerDiv = document.createElement('div');
                    headerDiv.className = 'test-header';
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'test-name';
                    nameDiv.textContent = result.name;
                    
                    const statusDiv = document.createElement('div');
                    statusDiv.className = `test-status ${result.passed ? 'status-passed' : 'status-failed'}`;
                    statusDiv.textContent = result.passed ? 'âœ“ PASSED' : 'âœ— FAILED';
                    
                    headerDiv.appendChild(nameDiv);
                    headerDiv.appendChild(statusDiv);
                    testDiv.appendChild(headerDiv);
                    
                    if (result.details) {
                        const detailsDiv = document.createElement('div');
                        detailsDiv.className = 'test-details';
                        detailsDiv.textContent = result.details;
                        testDiv.appendChild(detailsDiv);
                    }
                    
                    if (result.error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'error-details';
                        errorDiv.textContent = result.error;
                        testDiv.appendChild(errorDiv);
                    }
                    
                    categoryDiv.appendChild(testDiv);
                });
                
                resultsDiv.appendChild(categoryDiv);
            });
            
            // Update stats
            document.getElementById('total-tests').textContent = totalTests;
            document.getElementById('passed-tests').textContent = passedTests;
            document.getElementById('failed-tests').textContent = failedTests;
            document.getElementById('test-time').textContent = `${(performance.now() - startTime).toFixed(0)}ms`;
        }
        
        function clearResults() {
            document.getElementById('test-results').innerHTML = '';
            document.getElementById('total-tests').textContent = '0';
            document.getElementById('passed-tests').textContent = '0';
            document.getElementById('failed-tests').textContent = '0';
            document.getElementById('test-time').textContent = '0ms';
            document.getElementById('progress').style.width = '0%';
            document.getElementById('progress').textContent = '0%';
        }
        
        // Run tests on load
        window.addEventListener('DOMContentLoaded', () => {
            console.log(`Comprehensive test suite loaded with ${comprehensiveTests.length} tests`);
        });
    </script>
</body>
</html>