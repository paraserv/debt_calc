<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Debt Payoff Calculator</title>
    <meta name="description" content="Compare Snowball, Avalanche, Cash Flow Index, Credit Score, and Custom strategies. Build payoff schedules, export CSV, and track progress.">
    <meta property="og:title" content="Advanced Debt Payoff Calculator">
    <meta property="og:description" content="Interactive tool to plan and compare debt payoff strategies with exports and dark mode.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://paraserv.github.io/debt_calc/">
    <meta name="theme-color" content="#0f172a">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2d3748;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 20px;
        }
        
        .top-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 1200px) {
            .top-section {
                grid-template-columns: 1fr;
            }
        }
        
        .control-panel {
            background: #f7fafc;
            padding: 20px;
            border-radius: 10px;
        }
        
        .control-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
        }
        
        .input-group.inline {
            flex-direction: row;
            align-items: center;
            gap: 10px;
        }
        
        label {
            margin-bottom: 5px;
            color: #4a5568;
            font-weight: 600;
            font-size: 14px;
        }
        
        input, select {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        input[type="month"] {
            min-width: 160px;
        }
        
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            opacity: 1;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 600;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.small {
            padding: 5px 10px;
            font-size: 12px;
        }
        
        button.danger {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
        }
        
        button.success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
        }
        
        button.warning {
            background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
        }
        
        .method-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .method-btn {
            flex: 1;
            padding: 12px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .method-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }
        
        .method-btn:hover {
            border-color: #667eea;
        }
        
        .method-title {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .method-desc {
            font-size: 11px;
            opacity: 0.8;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
        }
        
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: 600;
            font-size: 13px;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        th[colspan] {
            text-align: center;
        }
        
        #amortizationTable th {
            font-size: 11px;
            padding: 8px 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        
        #amortizationTable td {
            font-size: 11px;
            padding: 6px 4px;
            white-space: nowrap;
        }
        
        td {
            padding: 8px;
            border-bottom: 1px solid #e2e8f0;
            font-size: 13px;
        }
        
        tr:hover {
            background: #f7fafc;
        }
        
        .drag-handle {
            cursor: move;
            padding: 5px;
            color: #a0aec0;
            font-size: 20px;
            user-select: none;
        }
        
        .drag-handle:hover {
            color: #667eea;
        }
        
        .dragging {
            opacity: 0.5;
        }
        
        .drag-over {
            background: #e6fffa;
        }
        
        .summary {
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            color: #2d3748;
            padding: 20px;
            border-radius: 10px;
        }
        
        .summary h3 {
            color: #2d3748;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .summary-item {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .summary-label {
            font-size: 12px;
            color: #718096;
            margin-bottom: 5px;
        }
        
        .summary-value {
            font-size: 24px;
            font-weight: bold;
            color: #2d3748;
        }
        
        .summary-date {
            font-size: 14px;
            margin-top: 5px;
            color: #4a5568;
        }
        
        .paid-off {
            background: #c6f6d5;
        }
        
        .current-focus {
            background: #fef5e7;
        }
        
        .snowball-payment {
            background: #bee3f8;
            font-weight: bold;
        }
        
        .high-utilization {
            color: #dc2626;
            font-weight: bold;
        }
        
        h2 {
            color: #2d3748;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        .extra-payments {
            background: #f0fff4;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .extra-payments-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 10px;
        }
        
        .extra-payments-list.collapsed {
            max-height: 150px;
        }
        
        .extra-payment-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            position: relative;
        }
        
        .extra-payment-row.before-start {
            background: rgba(254, 215, 215, 0.8); /* Semi-transparent background instead of opacity */
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #fc8181;
        }
        

        
        .extra-payments-summary {
            background: #e6fffa;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #234e52;
        }
        
        .expand-collapse-btn {
            padding: 5px 10px;
            font-size: 12px;
            background: white;
            border: 1px solid #38b2ac;
            color: #38b2ac;
            cursor: pointer;
        }
        
        /* Custom Calendar Styles */
        .date-picker-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .date-display {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 5px;
            background: white;
            cursor: pointer;
            min-width: 180px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        
        .date-display:hover {
            border-color: #667eea;
        }
        
        .calendar-popup {
            position: fixed;
            z-index: 10000;
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            display: none;
            min-width: 320px;
            max-height: 380px;
            overflow-y: auto;
        }
        
        .calendar-popup.show {
            display: block;
        }


        
        /* Ensure proper stacking context */
        .extra-payments {
            background: #f0fff4;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .extra-payments-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 10px;
        }
        
        .extra-payments-list.collapsed {
            max-height: 150px;
        }
        

        
        .before-start-warning {
            position: absolute;
            right: 80px;
            top: 50%;
            transform: translateY(-50%);
            color: #c53030;
            font-size: 11px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.9);
            padding: 3px 6px;
            border-radius: 4px;
            border: 1px solid #fc8181;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            z-index: 10;
        }
        
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .month-year-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .month-selector, .year-selector {
            padding: 5px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .calendar-nav {
            display: flex;
            gap: 5px;
        }
        
        .calendar-nav button {
            padding: 5px 10px;
            font-size: 16px;
            background: #f7fafc;
            border: 1px solid #e2e8f0;
        }
        
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }
        
        .calendar-day-header {
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            color: #718096;
            padding: 5px;
        }
        
        .calendar-day {
            text-align: center;
            padding: 8px;
            border: 1px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .calendar-day:hover:not(.disabled) {
            background: #f7fafc;
            border-color: #667eea;
        }
        
        .calendar-day.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .calendar-day.disabled {
            color: #cbd5e0;
            cursor: not-allowed;
        }
        
        .calendar-day.other-month {
            color: #a0aec0;
        }
        
        .calendar-day.today {
            border: 2px solid #667eea;
            font-weight: bold;
        }
        
        /* Schedule Modal */
        .schedule-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .schedule-modal.show {
            display: flex;
        }
        
        .schedule-modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            width: 90%;
        }
        
        .schedule-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .schedule-form h3 {
            margin-bottom: 10px;
            color: #2d3748;
        }
        
        .schedule-form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .schedule-form-group label {
            font-size: 14px;
            color: #4a5568;
            font-weight: 600;
        }
        
        .schedule-form-group input,
        .schedule-form-group select {
            padding: 8px;
            border: 2px solid #e2e8f0;
            border-radius: 5px;
        }
        
        .schedule-preview {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .schedule-preview-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .schedule-preview-item:last-child {
            border-bottom: none;
        }
        
        .schedule-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .comparison-table {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .comparison-card {
            background: #f7fafc;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .comparison-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .comparison-card.best-interest {
            border-color: #48bb78;
            background: #f0fff4;
        }
        
        .comparison-card.best-time {
            border-color: #4299e1;
            background: #ebf8ff;
        }
        
        .comparison-card.current-method {
            border-width: 3px;
            border-color: #667eea;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.3);
        }
        
        .comparison-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2d3748;
            font-size: 14px;
        }
        
        .comparison-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        .comparison-feature {
            color: #48bb78;
            text-align: center;
            margin-top: 10px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .comparison-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin-top: 5px;
        }
        
        .badge-money {
            background: #c6f6d5;
            color: #22543d;
        }
        
        .badge-time {
            background: #bee3f8;
            color: #2c5282;
        }
        
        .scroll-container {
            overflow-x: auto;
            margin-bottom: 30px;
        }
        
        #debtTable input {
            width: 100%;
            border: 1px solid #e2e8f0;
            padding: 5px;
            border-radius: 3px;
        }
        
        #debtTable input[type="text"],
        #debtTable input[type="number"] {
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }

        .warning-message {
            background: #fef3c7;
            color: #92400e;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: none;
        }
        
        .date-display {
            color: #4a5568;
            font-size: 14px;
            margin-top: 10px;
        }
        
        .payoff-dates {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .payoff-dates h4 {
            color: #2d3748;
            margin-bottom: 10px;
        }
        
        .payoff-date-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e2e8f0;
            color: #4a5568;
        }
        
        .payoff-date-item:last-child {
            border-bottom: none;
        }
        
        .extra-in-payment {
            color: #059669;
            font-weight: bold;
            font-size: 11px;
        }
        
        .debt-totals {
            background: #f7fafc;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            gap: 30px;
            font-weight: 600;
        }
        
        .debt-total-item {
            color: #2d3748;
        }
        
        .schedule-ellipsis {
            text-align: center;
            font-style: italic;
            color: #718096;
            padding: 10px;
            background: #f7fafc;
        }

        .debt-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .debt-type-btn {
            padding: 5px 10px;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .debt-type-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .info-tooltip {
            display: inline-block;
            margin-left: 5px;
            color: #4299e1;
            cursor: help;
            font-size: 12px;
            position: relative;
        }

        .info-tooltip:hover::after, .info-tooltip.sticky::after {
            content: attr(data-tooltip);
            position: absolute;
            background: #2d3748;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: normal;
            width: 250px;
            z-index: 10000;
            top: 25px;
            left: -100px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .method-btn .info-tooltip:hover::after, .method-btn .info-tooltip.sticky::after {
            top: 100%;
            left: -100px;
            margin-top: 5px;
        }

        /* Unified tooltip for buttons and controls */
        .has-tooltip[data-tooltip] {
            position: relative;
        }
        .has-tooltip[data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 6px);
            left: 50%;
            transform: translateX(-50%);
            background: #2d3748;
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 12px;
            white-space: normal;
            width: max-content;
            max-width: 260px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            opacity: 0;
            animation: tooltipFade 0.2s ease forwards;
            animation-delay: 1s; /* show quicker but avoid jitter */
            z-index: 10000;
        }
        @keyframes tooltipFade { from { opacity: 0; } to { opacity: 1; } }
        
        .debug-info {
            background: #f0f4f8;
            border: 1px solid #cbd5e0;
            padding: 10px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #4a5568;
        }
        
        /* Dark mode overrides */
        body.dark {
            background: linear-gradient(135deg, #0f172a 0%, #111827 100%);
            color: #e5e7eb;
        }
        body.dark .container {
            background: #0b1220;
            color: #e5e7eb;
        }
        body.dark h1 { color: #e5e7eb; }
        body.dark .subtitle { color: #9ca3af; }
        body.dark .control-panel { background: #111827; }
        body.dark label { color: #cbd5e1; }
        body.dark input, body.dark select {
            background: #0f172a;
            color: #e5e7eb;
            border-color: #374151;
        }
        body.dark input:focus, body.dark select:focus { border-color: #818cf8; }
        body.dark #totalMinimums, body.dark #extraAvailable { background: #0f172a !important; color: #e5e7eb; border-color: #374151; }
        body.dark tr:hover { background: #0f172a; }
        body.dark .drag-over { background: #0d1a22; }
        body.dark .debt-totals { background: #0f172a; }
        body.dark .debt-type-btn { background: #0f172a; border-color: #374151; color: #e5e7eb; }
        body.dark .expand-collapse-btn { background: #0f172a; border-color: #34d399; color: #34d399; }
        body.dark .date-display { background: #0f172a; border-color: #374151; color: #e5e7eb; }
        body.dark .calendar-popup { background: #0f172a; border-color: #374151; color: #e5e7eb; }
        body.dark .calendar-nav button { background: #0b1220; border-color: #374151; color: #e5e7eb; }
        body.dark .calendar-day:hover:not(.disabled) { background: #0b1220; border-color: #374151; }
        body.dark .summary { background: #0f172a; border-color: #1f2937; color: #e5e7eb; }
        body.dark .summary h3 { color: #e5e7eb; }
        body.dark .summary-item { background: #0b1220; border-color: #1f2937; }
        body.dark .summary-label { color: #9ca3af; }
        body.dark .summary-value { color: #e5e7eb; }
        body.dark .summary-date { color: #9ca3af; }
        body.dark .payoff-dates { background: #0b1220; border-color: #1f2937; }
        body.dark .payoff-dates h4 { color: #e5e7eb; }
        body.dark .extra-payments { background: #0d1f17; }
        body.dark .extra-payments-summary { background: #0d1a22; }
        body.dark .debug-info { background: #0f172a; border-color: #1f2937; color: #9ca3af; }
        body.dark .method-btn { background: #0f172a; border-color: #374151; color: #e5e7eb; }
        body.dark .method-btn.active { border-color: #818cf8; }
        body.dark th { background: linear-gradient(135deg, #1f2937 0%, #111827 100%); color: #e5e7eb; }
        body.dark .schedule-modal-content { background: #0f172a; }
        body.dark .modal-content { background: #0f172a; color: #e5e7eb; }
        body.dark .comparison-card { background: #0b1220; border-color: #1f2937; }
        body.dark .comparison-card.baseline { background: #0b1220 !important; border-color: #1f2937 !important; }
        body.dark .comparison-card .comparison-feature { border-top: 1px solid #1f2937 !important; }
        body.dark .comparison-card.best-interest { background: #0d1f17; }
        body.dark .comparison-card.best-time { background: #0d1a22; }
        body.dark #amortizationTable td { color: #e5e7eb; }
        body.dark .paid-off { background: #173a2a; }
        body.dark .current-focus { background: #2a1f0f; }
        body.dark .extra-in-payment { color: #34d399; }
        body.dark .schedule-ellipsis { color: #9ca3af; }
        body.dark .schedule-ellipsis-row { background: #0f172a !important; border-color: #1f2937 !important; }
        body.dark .total-cell, body.dark .total-interest-cell, body.dark .total-principal-cell, body.dark .total-balance-cell { background: #0b1220 !important; }
        body.dark .total-interest-cell { color: #f87171 !important; }
        body.dark .total-principal-cell { color: #34d399 !important; }
        body.dark .totals-subheader-cell { background: #0b1220 !important; color: #cbd5e1 !important; }
        /* Fix bright backgrounds in various elements */
        body.dark .notification { background: #1f2937 !important; color: #e5e7eb !important; }
        body.dark .notification-warning { background: #2d2618 !important; color: #fbbf24 !important; }
        body.dark .notification-error { background: #2d1a1a !important; color: #f87171 !important; }
        body.dark .notification-success { background: #1a2d1f !important; color: #34d399 !important; }
        body.dark .debt-group { background: #0f172a !important; }
        body.dark .debt-items { background: #0b1220 !important; }
        body.dark .debt-header { background: #111827 !important; }
        body.dark .help-text { background: #1f2937 !important; color: #9ca3af !important; }
        body.dark .before-start { background: #2d1a1a !important; }
        body.dark .before-start-warning { color: #fbbf24 !important; }
        body.dark .payment-timeline { background: #0f172a !important; }
        body.dark .timeline-container { background: #0b1220 !important; }
        body.dark .error-message { background: #2d1a1a !important; color: #f87171 !important; }
        body.dark .warning-message { background: #2d2618 !important; color: #fbbf24 !important; }
        body.dark .info-message { background: #1a2333 !important; color: #60a5fa !important; }
        body.dark .phase-transition { background: #1f2937 !important; border-color: #374151 !important; }
        body.dark .phase-complete { background: #1a2d1f !important; border-color: #34d399 !important; }
        body.dark .payoff-collapse { background: #1f2937 !important; color: #9ca3af !important; }
        body.dark .schedule-preview { background: #0b1220; border: 1px solid #1f2937; }
        body.dark .payoff-collapse { background: #0f172a !important; color: #9ca3af !important; border: 1px solid #1f2937; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí∞ Advanced Debt Payoff Calculator</h1>
        <div style="display:flex;justify-content:flex-end;margin-bottom:10px;gap:10px;">
            <button class="small has-tooltip" id="themeToggle" data-tooltip="Toggle dark mode">üåô Dark</button>
        </div>
        <p class="subtitle">Compare strategies and optimize your debt payoff plan</p>
        
        <div class="error-message" id="errorMessage"></div>
        <div class="warning-message" id="warningMessage"></div>
        
        <div class="top-section">
            <div class="control-panel">
                <h3 style="margin-bottom: 15px;">üíµ Payment Settings</h3>
                <div class="control-row">
                    <div class="input-group">
                        <label for="totalMonthly">Total Monthly Payment:</label>
                        <input type="number" id="totalMonthly" value="3000" step="10" style="width: 100px;">
                    </div>
                    <div class="input-group">
                        <label>Start Date:</label>
                        <div class="date-picker-wrapper">
                            <div class="date-display" onclick="toggleStartDateCalendar()" id="startDateDisplay" role="button" tabindex="0" aria-label="Select start month">
                                <span id="startDateText">Select Month</span>
                                <span>üìÖ</span>
                            </div>
                            <input type="hidden" id="startDate" style="width: 180px;">
                            <div class="calendar-popup" id="startDateCalendar"></div>
                        </div>
                    </div>
                </div>
                <div class="control-row">
                    <div class="input-group">
                        <label>Total Min Payments:</label>
                        <input type="text" id="totalMinimums" value="$800" readonly style="background: #e2e8f0; width: 100px;">
                    </div>
                    <div class="input-group">
                        <label>Extra Available:</label>
                        <input type="text" id="extraAvailable" value="$2200" readonly style="background: #e2e8f0; width: 100px;">
                    </div>
                </div>
            </div>
            
            <div class="summary">
                <h3>üìà Current Strategy Summary</h3>
                <div class="summary-grid" id="summary"></div>
                <div class="payoff-dates" id="payoffDates"></div>
            </div>
        </div>

        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px;">
            <div class="method-selector" style="flex: 1; margin-bottom: 0;">
                <div class="method-btn active" onclick="setMethod('snowball')" id="method-snowball" data-tooltip="Pays off smallest debts first for psychological wins and motivation. Great for building momentum and confidence in your debt payoff journey.">
                    <div class="method-title">‚ùÑÔ∏è Snowball</div>
                    <div class="method-desc">Lowest balance first</div>
                    <span class="info-tooltip" data-tooltip="">‚ÑπÔ∏è</span>
                </div>
                <div class="method-btn" onclick="setMethod('avalanche')" id="method-avalanche" data-tooltip="Mathematically optimal - pays highest interest rate debts first to minimize total interest paid. Saves the most money over time.">
                    <div class="method-title">üèîÔ∏è Avalanche</div>
                    <div class="method-desc">Highest rate first</div>
                    <span class="info-tooltip" data-tooltip="">‚ÑπÔ∏è</span>
                </div>
                <div class="method-btn" onclick="setMethod('cfi')" id="method-cfi" data-tooltip="Cash Flow Index prioritizes debts that free up monthly cash flow fastest. CFI = Balance √∑ (Payment - Interest). Lower CFI means faster cash flow improvement.">
                    <div class="method-title">üí∏ Cash Flow</div>
                    <div class="method-desc">Best CFI first</div>
                    <span class="info-tooltip" data-tooltip="">‚ÑπÔ∏è</span>
                </div>
                <div class="method-btn" onclick="setMethod('utilization')" id="method-utilization" data-tooltip="Advanced waterfall strategy with 5 phases: Phase 1: Emergency (89% threshold), Phase 2: Critical (49%), Phase 3: Good Standing (29%), Phase 4: Premium (10% overall), Phase 5: AZEO optimization. Systematically improves credit score for balance transfer qualification.">
                    <div class="method-title">üìà Credit Score</div>
                    <div class="method-desc">Waterfall strategy</div>
                    <span class="info-tooltip" data-tooltip="">‚ÑπÔ∏è</span>
                </div>
                <div class="method-btn" onclick="setMethod('custom')" id="method-custom" data-tooltip="Drag and drop debts in the table below to set your own custom payoff order based on your personal priorities.">
                    <div class="method-title">üéØ Custom</div>
                    <div class="method-desc">Your order</div>
                    <span class="info-tooltip" data-tooltip="">‚ÑπÔ∏è</span>
                </div>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <button id="syncCustomBtn" class="small has-tooltip" data-tooltip="Copy the current method‚Äôs order into Custom" onclick="syncCustomOrderToCurrentMethod()">üîÅ Customize from <span id="syncMethodLabel">METHOD</span></button>
                <button class="has-tooltip" onclick="showComparison()" style="white-space: nowrap;" data-tooltip="Open a side-by-side comparison of all methods">üìä Compare All Methods</button>
            </div>
        </div>

        <h2>üìä Debt List</h2>
        <div class="debt-totals">
            <div class="debt-total-item">Total Debt: <span id="totalDebtAmount">$0</span></div>
            <div class="debt-total-item">Total Min Payments: <span id="totalMinAmount">$0</span></div>
            <div class="debt-total-item">Weighted Avg Rate: <span id="avgInterestRate">0%</span></div>
        </div>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span class="info-tooltip" style="font-size: 16px; color: #4299e1; cursor: help;" data-tooltip="The # column shows the payoff order for your selected method. Debt #1 gets all extra payments first, then #2, etc. The order changes when you switch methods. Drag rows to create a custom order.">‚ÑπÔ∏è</span>
            <button class="small success has-tooltip" onclick="addDebt()" data-tooltip="Add a new debt row">+ Add Debt</button>
            <button class="small danger has-tooltip" onclick="removeAllDebts()" data-tooltip="Remove all debts">üóëÔ∏è Remove All</button>
        </div>
        <div class="scroll-container">
            <table id="debtTable">
                <thead>
                    <tr>
                        <th><span style="color: white;">‚ò∞ #</span></th>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Balance</th>
                        <th>Rate %</th>
                        <th>Min Payment</th>
                        <th>Credit Limit</th>
                        <th>Util %</th>
                        <th>Monthly Interest</th>
                        <th>CFI (Months)</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="debtTableBody"></tbody>
            </table>
        </div>

        <div class="extra-payments">
            <h3>üíµ Extra Payments Schedule</h3>
            <div class="extra-payments-summary" id="extraPaymentsSummary" style="display: none;">
                <span id="extraPaymentsSummaryText">0 extra payments scheduled</span>
                <button class="expand-collapse-btn" onclick="toggleExtraPaymentsList()">Show All</button>
            </div>
            <div class="extra-payments-list" id="extraPaymentsList"></div>
            <div style="display:flex; gap:10px; margin-top:8px;">
                <button class="small success has-tooltip" onclick="addExtraPayment()" data-tooltip="Add a new extra payment row">+ Add Extra Payment</button>
                <button class="small danger has-tooltip" onclick="removeAllExtraPayments()" data-tooltip="Remove all extra payments">üóëÔ∏è Remove All</button>
                <button class="small has-tooltip" onclick="copyConfigurationJSON()" data-tooltip="Copy current configuration (debts, extra payments, method, totals, start date) to clipboard as JSON. Paste to a text editor or share; restore using Load Configuration (JSON file).">üìã Copy JSON</button>
            </div>
            <div class="debug-info" id="debugInfo" style="display: none;"></div>
        </div>

        <h2>üìÖ Payoff Schedule</h2>
        <div id="scheduleControls" style="display: none; padding: 10px; background: #2d3748; border-radius: 8px 8px 0 0; margin-bottom: 0;">
            <!-- Control row will be inserted here -->
        </div>
        <div class="scroll-container">
            <table id="amortizationTable">
                <thead>
                    <tr id="amortizationHeader"></tr>
                </thead>
                <tbody id="amortizationBody"></tbody>
            </table>
        </div>

        <div class="export-buttons">
            <button class="has-tooltip" onclick="exportToCSV()" data-tooltip="Download a detailed monthly schedule as CSV">üì• Export Detailed Schedule to CSV</button>
            <button class="has-tooltip" onclick="exportSimplifiedToCSV()" data-tooltip="Download a condensed schedule as CSV">üì• Export Simple Schedule to CSV</button>
            <button class="has-tooltip" onclick="exportDebtListToCSV()" data-tooltip="Download your debt list as CSV">üì• Export Debt List to CSV</button>
            <button class="has-tooltip" onclick="saveConfiguration()" data-tooltip="Save current configuration to a JSON file">üíæ Save Configuration</button>
            <button class="has-tooltip" onclick="loadConfiguration()" data-tooltip="Load a configuration from a JSON file">üìÇ Load Configuration</button>
            <button class="danger has-tooltip" onclick="resetAll()" data-tooltip="Reset all data and clear local storage">üßπ Reset All</button>
        </div>
    </div>

    <div id="comparisonModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="comparisonTitle">
        <div class="modal-content" tabindex="-1">
            <h2 id="comparisonTitle">Method Comparison</h2>
            <div id="comparisonResults" class="comparison-table"></div>
            <button onclick="closeModal()" style="margin-top: 20px;">Close</button>
        </div>
    </div>

    <script>
        // Data structure
        let debts = [
            { 
                id: 1,
                name: "Credit Card 1",
                type: "credit",
                balance: 3500, 
                rate: 18.99, 
                minPayment: 105,
                creditLimit: 5000,
                customOrder: 1
            },
            { 
                id: 2,
                name: "Personal Loan",
                type: "loan",
                balance: 8200, 
                rate: 12.50, 
                minPayment: 245,
                creditLimit: null,
                customOrder: 2
            },
            { 
                id: 3,
                name: "Credit Card 2",
                type: "credit",
                balance: 15000, 
                rate: 21.99, 
                minPayment: 450,
                creditLimit: 20000,
                customOrder: 3
            }
        ];

        let extraPayments = [];
        let currentMethod = 'snowball';
        let totalMonthlyPayment = 3000;
        let draggedRow = null;
        let nextDebtId = 4;
        let startDate = new Date();
        let lastCalculatedMinPayments = {};
        
        // Helper function for theme-aware colors
        function getThemeColor(lightColor, darkColor) {
            return document.body.classList.contains('dark') ? darkColor : lightColor;
        }

        // Initialize start date to current month
        function initializeStartDate() {
            const year = startDate.getFullYear();
            const month = String(startDate.getMonth() + 1).padStart(2, '0');
            const dateStr = `${year}-${month}`;
            document.getElementById('startDate').value = dateStr;
            document.getElementById('startDateText').textContent = formatMonthYear(dateStr);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function formatNumber(num) {
            return num.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        }

        function formatCurrency(num) {
            return '$' + formatNumber(Math.round(num));
        }

        function getPayoffDate(monthsFromNow) {
            const dateStr = document.getElementById('startDate').value;
            if (!dateStr) return 'N/A';
            
            const [year, month] = dateStr.split('-');
            const date = new Date(parseInt(year), parseInt(month) - 1, 1);
            date.setMonth(date.getMonth() + monthsFromNow);
            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        }

        function getMonthDate(monthNum) {
            const dateStr = document.getElementById('startDate').value;
            if (!dateStr) return `Month ${monthNum}`;
            
            const [year, month] = dateStr.split('-');
            const date = new Date(parseInt(year), parseInt(month) - 1, 1);
            date.setMonth(date.getMonth() + monthNum - 1);
            return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showWarning(message) {
            const warningDiv = document.getElementById('warningMessage');
            warningDiv.textContent = message;
            warningDiv.style.display = 'block';
            setTimeout(() => {
                warningDiv.style.display = 'none';
            }, 8000);
        }

        function calculateMonthlyInterest(balance, rate) {
            return balance * (rate / 100 / 12);
        }

        function calculateCFI(balance, minPayment, rate) {
            if (!minPayment || minPayment === 0) return Infinity;
            
            const monthlyInterest = calculateMonthlyInterest(balance, rate);
            const principal = minPayment - monthlyInterest;
            
            if (principal <= 0) return Infinity;
            
            // CFI = Balance / Principal portion of payment
            return balance / principal;
        }

        function calculateUtilization(balance, creditLimit) {
            if (!creditLimit || creditLimit === 0) return null;
            return (balance / creditLimit) * 100;
        }

        function calculateDefaultMinPayment(balance, rate, debtType = 'credit') {
            const monthlyInterest = calculateMonthlyInterest(balance, rate);
            
            if (debtType === 'credit') {
                // Credit card minimum payment calculation
                // Based on research: typically 2-3% of balance or $25-35, whichever is higher
                
                const percentOfBalance = balance * 0.02; // 2% of balance
                const minimumFloor = 35; // Most common floor
                
                // Calculate the base minimum
                let minPayment = Math.max(percentOfBalance, minimumFloor);
                
                // Ensure it covers interest plus at least $5 toward principal
                minPayment = Math.max(minPayment, monthlyInterest + 5);
                
                // For very high interest cards (>30%), use 3% instead
                if (rate > 30) {
                    const higherPercent = balance * 0.03;
                    minPayment = Math.max(higherPercent, minimumFloor, monthlyInterest + 10);
                }
                
                // Round to nearest $5 for cleaner numbers
                return Math.ceil(minPayment / 5) * 5;
                
            } else if (debtType === 'loan') {
                // Personal loan - calculate as amortized payment
                // Assume 36-month term as default for personal loans
                const months = 36;
                const monthlyRate = rate / 100 / 12;
                
                if (monthlyRate === 0) {
                    return Math.ceil(balance / months / 10) * 10;
                }
                
                // Standard amortization formula
                const payment = balance * (monthlyRate * Math.pow(1 + monthlyRate, months)) / 
                               (Math.pow(1 + monthlyRate, months) - 1);
                
                // Round to nearest $10
                return Math.ceil(payment / 10) * 10;
            }
            
            // Default fallback
            return Math.max(35, monthlyInterest + 10);
        }

        function sortDebtsCopy(debtsCopy, method) {
            const sortFunctions = {
                'snowball': (a, b) => {
                    if (a.balance !== b.balance) return a.balance - b.balance;
                    return a.id - b.id; // Stable tie-breaker
                },
                'avalanche': (a, b) => {
                    if (b.rate !== a.rate) return b.rate - a.rate;
                    return a.id - b.id; // Stable tie-breaker
                },
                'cfi': (a, b) => {
                    const cfiA = calculateCFI(a.balance, a.minPayment, a.rate);
                    const cfiB = calculateCFI(b.balance, b.minPayment, b.rate);
                    if (cfiA !== cfiB) return cfiA - cfiB;
                    return a.id - b.id; // Stable tie-breaker
                },
                'utilization': (a, b) => {
                    const utilA = calculateUtilization(a.balance, a.creditLimit) || 0;
                    const utilB = calculateUtilization(b.balance, b.creditLimit) || 0;
                    
                    // For Credit Score method, we need a different approach
                    // Priority 1: Cards over 100% utilization
                    // Priority 2: Cards over 30% utilization (highest util first)
                    // Priority 3: All other debts by highest rate
                    
                    // Both over 100%
                    if (utilA > 100 && utilB > 100) {
                        if (utilB !== utilA) return utilB - utilA;
                        return a.id - b.id;
                    }
                    
                    // One over 100%
                    if (utilA > 100) return -1;
                    if (utilB > 100) return 1;
                    
                    // Both over 30%
                    if (utilA > 30 && utilB > 30) {
                        if (utilB !== utilA) return utilB - utilA;
                        return a.id - b.id;
                    }
                    
                    // One over 30%
                    if (utilA > 30) return -1;
                    if (utilB > 30) return 1;
                    
                    // Both under 30% or non-credit cards - use avalanche
                    if (b.rate !== a.rate) return b.rate - a.rate;
                    return a.id - b.id;
                },
                'custom': (a, b) => {
                    if (a.customOrder !== b.customOrder) return (a.customOrder || 999) - (b.customOrder || 999);
                    return a.id - b.id;
                }
            };
            
            if (sortFunctions[method]) {
                debtsCopy.sort(sortFunctions[method]);
            }
            return debtsCopy;
        }

        function setMethod(method, fromDrag = false) {
            currentMethod = method;
            document.querySelectorAll('.method-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`method-${method}`).classList.add('active');
            
            // Don't re-sort the physical array - just update the display
            updateDebtTable();
            updateAmortizationTable();
            updateSyncButtonState();
            persistToLocalStorage();
        }

        function updateDebtTable() {
            const tbody = document.getElementById('debtTableBody');
            tbody.innerHTML = '';
            
            const totalDebt = debts.reduce((sum, d) => sum + (d.balance || 0), 0);
            const totalMin = debts.reduce((sum, d) => sum + (d.minPayment || 0), 0);
            
            // Calculate weighted average interest rate
            const weightedRate = totalDebt > 0 ? 
                debts.reduce((sum, d) => sum + ((d.rate || 0) * (d.balance || 0)), 0) / totalDebt : 0;
            
            document.getElementById('totalDebtAmount').textContent = formatCurrency(totalDebt);
            document.getElementById('totalMinAmount').textContent = formatCurrency(totalMin);
            document.getElementById('avgInterestRate').textContent = weightedRate.toFixed(2) + '%';
            document.getElementById('totalMinimums').value = formatCurrency(totalMin);
            document.getElementById('extraAvailable').value = formatCurrency(Math.max(0, totalMonthlyPayment - totalMin));
            
            // Check if payment is sufficient
            if (totalMonthlyPayment < totalMin) {
                showWarning(`Warning: Total monthly payment (${formatCurrency(totalMonthlyPayment)}) is less than total minimum payments (${formatCurrency(totalMin)}). Please increase your monthly payment.`);
            }
            
            // Get the payoff order for the current method
            const sortedDebts = [...debts];
            sortDebtsCopy(sortedDebts, currentMethod);
            const payoffOrder = {};
            sortedDebts.forEach((debt, index) => {
                payoffOrder[debt.id] = index + 1;
            });
            
            // Update custom order based on current position
            debts.forEach((debt, index) => {
                debt.customOrder = index + 1;
                
                const row = tbody.insertRow();
                row.dataset.debtId = debt.id;
                
                const monthlyInterest = calculateMonthlyInterest(debt.balance, debt.rate);
                const cfi = calculateCFI(debt.balance, debt.minPayment, debt.rate);
                const utilization = calculateUtilization(debt.balance, debt.creditLimit);
                const utilizationClass = utilization > 100 ? 'high-utilization' : '';
                
                // Show payoff order based on current method
                const orderDisplay = currentMethod === 'custom' ? index + 1 : payoffOrder[debt.id];
                
                // Type selector HTML with proper tab order
                const typeSelector = `
                    <select onchange="updateDebtField(${debt.id}, 'type', this.value)" style="width: 80px;">
                        <option value="credit" ${debt.type === 'credit' ? 'selected' : ''}>Credit</option>
                        <option value="loan" ${debt.type === 'loan' ? 'selected' : ''}>Loan</option>
                    </select>
                `;
                
                row.innerHTML = `
                    <td>
                        <span class="drag-handle" draggable="true" title="Drag to reorder">‚ò∞</span>
                        <span style="font-weight: bold; color: #667eea;" title="Payoff order for ${escapeHtml(currentMethod)} method">${orderDisplay}</span>
                    </td>
                    <td><input type="text" value="${escapeHtml(debt.name)}" onblur="updateDebtField(${debt.id}, 'name', this.value)"></td>
                    <td>${typeSelector}</td>
                    <td><input type="number" value="${debt.balance}" step="10" onblur="updateDebtField(${debt.id}, 'balance', parseFloat(this.value))"></td>
                    <td><input type="number" value="${debt.rate}" step="0.01" onblur="updateDebtField(${debt.id}, 'rate', parseFloat(this.value))"></td>
                    <td><input type="number" value="${debt.minPayment}" step="10" onblur="updateDebtField(${debt.id}, 'minPayment', parseFloat(this.value))"></td>
                    <td><input type="number" value="${debt.creditLimit || ''}" step="10" placeholder="N/A" onblur="updateDebtField(${debt.id}, 'creditLimit', this.value ? parseFloat(this.value) : null)"></td>
                    <td class="${utilizationClass}">${utilization !== null ? utilization.toFixed(1) + '%' : 'N/A'}</td>
                    <td>${formatCurrency(monthlyInterest)}</td>
                    <td>${cfi === Infinity ? '‚àû' : cfi.toFixed(1)}</td>
                    <td><button class="small danger" onclick="removeDebt(${debt.id})">Remove</button></td>
                `;
                
                // Only allow dragging from the drag handle
                const dragHandle = row.querySelector('.drag-handle');
                dragHandle.addEventListener('dragstart', (e) => handleDragStart(e, row));
                dragHandle.addEventListener('dragend', handleDragEnd);
                
                row.addEventListener('dragover', handleDragOver);
                row.addEventListener('drop', handleDrop);
                row.addEventListener('dragleave', handleDragLeave);
            });
            updateSyncButtonState();
            persistToLocalStorage();
        }

        function updateDebtField(debtId, field, value) {
            const debt = debts.find(d => d.id === debtId);
            if (!debt) return;
            
            const oldValue = debt[field];
            
            // Validate numeric fields
            if (field === 'balance' || field === 'rate' || field === 'minPayment' || field === 'creditLimit') {
                if (field !== 'creditLimit' || value !== null) {
                    value = parseFloat(value);
                    if (isNaN(value) || value < 0) {
                        value = 0;
                    }
                    // Max reasonable values
                    if (field === 'rate' && value > 100) value = 100;
                    if (field === 'balance' && value > 10000000) value = 10000000;
                    if (field === 'minPayment' && value > debt.balance) value = debt.balance;
                }
            }
            
            debt[field] = value;
            
            // Handle type changes - set appropriate credit limit defaults
            if (field === 'type') {
                if (value === 'credit' && !debt.creditLimit) {
                    debt.creditLimit = debt.balance; // Default credit limit to current balance
                } else if (value === 'loan') {
                    debt.creditLimit = null; // Loans don't have credit limits
                }
            }
            
            // When balance changes on a credit card, update credit limit if it's null or equal to old balance
            if (field === 'balance' && debt.type === 'credit') {
                if (!debt.creditLimit || debt.creditLimit === oldValue) {
                    debt.creditLimit = value;
                }
            }
            
            // Mark if user manually edited min payment
            if (field === 'minPayment') {
                debt.userEditedMin = true;
            }
            
            // Auto-calculate minimum payment when balance, rate, or type changes (unless user edited)
            if ((field === 'balance' || field === 'rate' || field === 'type') && debt.balance && debt.rate && !debt.userEditedMin) {
                // Create a unique key for this debt's last calculated min payment
                const debtKey = `${debt.id}_${debt.type}_${Math.round(debt.balance)}_${debt.rate.toFixed(2)}`;
                
                // Only update if parameters have changed
                if (!lastCalculatedMinPayments[debt.id] || lastCalculatedMinPayments[debt.id] !== debtKey) {
                    debt.minPayment = calculateDefaultMinPayment(debt.balance, debt.rate, debt.type || 'credit');
                    lastCalculatedMinPayments[debt.id] = debtKey;
                }
            }
            
            if (window._recalcTimer) clearTimeout(window._recalcTimer);
            window._recalcTimer = setTimeout(() => {
                updateDebtTable();
                updateAmortizationTable();
            }, 150);
        }

        function addDebt() {
            const newId = nextDebtId++;
            const defaultBalance = 1000;
            const defaultRate = 15;
            const defaultType = 'credit';
            
            debts.push({
                id: newId,
                name: `New Debt ${newId}`,
                type: defaultType,
                balance: defaultBalance,
                rate: defaultRate,
                minPayment: calculateDefaultMinPayment(defaultBalance, defaultRate, defaultType),
                creditLimit: defaultType === 'credit' ? defaultBalance : null,
                customOrder: debts.length + 1
            });
            updateDebtTable();
            updateAmortizationTable();
            persistToLocalStorage();
            // Scroll to newly added row
            setTimeout(() => {
                const tbody = document.getElementById('debtTableBody');
                if (tbody && tbody.lastElementChild) {
                    tbody.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    const nameInput = tbody.lastElementChild.querySelector('input[type="text"]');
                    if (nameInput) nameInput.focus();
                }
            }, 0);
        }

        function removeDebt(debtId) {
            debts = debts.filter(d => d.id !== debtId);
            updateDebtTable();
            updateAmortizationTable();
            updateSyncButtonState();
            persistToLocalStorage();
        }

        function removeAllDebts() {
            if (!confirm('Remove all debts?')) return;
            debts = [];
            nextDebtId = 1;
            updateDebtTable();
            updateAmortizationTable();
            persistToLocalStorage();
        }

        function handleDragStart(e, row) {
            draggedRow = row;
            row.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(e) {
            e.preventDefault();
            if (this !== draggedRow) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            
            if (draggedRow && draggedRow !== this) {
                const draggedId = parseInt(draggedRow.dataset.debtId);
                const targetId = parseInt(this.dataset.debtId);
                
                const draggedIndex = debts.findIndex(d => d.id === draggedId);
                const targetIndex = debts.findIndex(d => d.id === targetId);
                
                if (draggedIndex !== -1 && targetIndex !== -1) {
                    const draggedDebt = debts[draggedIndex];
                    debts.splice(draggedIndex, 1);
                    debts.splice(targetIndex, 0, draggedDebt);
                    
                    // Switch to custom method when user drags
                    if (currentMethod !== 'custom') {
                        setMethod('custom', true);
                    }
                    
                    updateDebtTable();
                    updateAmortizationTable();
                    updateSyncButtonState();
                }
            }
        }

        function handleDragEnd(e) {
            if (draggedRow) {
                draggedRow.classList.remove('dragging');
            }
            document.querySelectorAll('.drag-over').forEach(row => row.classList.remove('drag-over'));
            draggedRow = null;
        }

        function addExtraPayment(copyFrom = null) {
            const container = document.getElementById('extraPaymentsList');
            const row = document.createElement('div');
            row.className = 'extra-payment-row';
            
            const defaultMonth = copyFrom ? copyFrom.displayDate : '';
            const defaultAmount = copyFrom ? copyFrom.amount : '';
            const defaultDesc = copyFrom ? copyFrom.description : '';
            
            // Create a unique ID for this row's calendar
            const rowId = 'extra-row-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            
            row.innerHTML = `
                <div class="date-picker-wrapper">
                    <div class="date-display" onclick="toggleCalendar('${rowId}')" id="date-display-${rowId}" role="button" tabindex="0" aria-label="Select month">
                        <span>${defaultMonth ? formatMonthYear(defaultMonth) : 'Select Month'}</span>
                        <span>üìÖ</span>
                    </div>
                    <input type="hidden" id="date-input-${rowId}" value="${defaultMonth}" onchange="updateExtraPayments()">
                    <div class="calendar-popup" id="calendar-${rowId}"></div>
                </div>
                <input type="number" placeholder="Amount" value="${defaultAmount}" step="10" style="width: 150px;" onchange="updateExtraPayments()">
                <input type="text" placeholder="Description" value="${defaultDesc}" style="flex: 1;" onchange="updateExtraPayments()">
                <button class="small" onclick="openScheduleModal(this)" style="background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);">üìÖ Schedule</button>
                <button class="small warning" onclick="duplicateExtraPayment(this)">Duplicate</button>
                <button class="small danger" onclick="removeExtraPayment(this)">Remove</button>
                <span class="before-start-warning" style="display: none;">‚ö†Ô∏è IGNORED</span>
            `;
            container.appendChild(row);
            
            // Initialize the calendar for this row
            initializeCalendar(rowId, defaultMonth);
            
            // Check if this payment is before start date
            updateExtraPayments();
            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
            const amountInput = row.querySelector('input[type="number"]');
            if (amountInput) amountInput.focus();
        }
        
        function formatMonthYear(dateStr) {
            if (!dateStr) return '';
            const [year, month] = dateStr.split('-');
            const date = new Date(parseInt(year), parseInt(month) - 1);
            return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        }
        
        function initializeCalendar(rowId, initialDate) {
            const calendarEl = document.getElementById(`calendar-${rowId}`);
            const inputEl = document.getElementById(`date-input-${rowId}`);
            const displayEl = document.getElementById(`date-display-${rowId}`);
            
            let currentDate;
            if (initialDate) {
                const [year, month] = initialDate.split('-');
                currentDate = new Date(parseInt(year), parseInt(month) - 1);
            } else {
                // Default to start date or current date
                const startDateStr = document.getElementById('startDate').value;
                if (startDateStr) {
                    const [year, month] = startDateStr.split('-');
                    currentDate = new Date(parseInt(year), parseInt(month) - 1);
                } else {
                    currentDate = new Date();
                }
            }
            
            renderCalendar(rowId, currentDate);
        }
        
        function renderCalendar(rowId, date) {
            const calendarEl = document.getElementById(`calendar-${rowId}`);
            const inputEl = document.getElementById(`date-input-${rowId}`);
            
            const year = date.getFullYear();
            const month = date.getMonth();
            const today = new Date();
            
            // Get the selected date from the input
            const selectedValue = inputEl.value;
            let selectedYear = null, selectedMonth = null;
            if (selectedValue) {
                [selectedYear, selectedMonth] = selectedValue.split('-').map(n => parseInt(n));
            }
            
            let html = `
                <div class="calendar-header">
                    <div class="month-year-selector">
                        <select class="month-selector" onchange="changeMonth('${rowId}', this.value, ${year})">
            `;
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthNames.forEach((name, i) => {
                html += `<option value="${i}" ${i === month ? 'selected' : ''}>${name}</option>`;
            });
            
            html += `
                        </select>
                        <select class="year-selector" onchange="changeMonth('${rowId}', ${month}, this.value)">
            `;
            
            // Show years from 2 years ago to 5 years in the future
            const startYear = today.getFullYear() - 2;
            const endYear = today.getFullYear() + 5;
            for (let y = startYear; y <= endYear; y++) {
                html += `<option value="${y}" ${y === year ? 'selected' : ''}>${y}</option>`;
            }
            
            html += `
                        </select>
                    </div>
                    <div class="calendar-nav">
                        <button type="button" onclick="event.stopPropagation(); navigateMonth('${rowId}', -1)" style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer;">Prev</button>
                        <button type="button" onclick="event.stopPropagation(); navigateMonth('${rowId}', 1)" style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer;">Next</button>
                    </div>
                </div>
                <div class="calendar-grid">
                    <div class="calendar-day-header">Sun</div>
                    <div class="calendar-day-header">Mon</div>
                    <div class="calendar-day-header">Tue</div>
                    <div class="calendar-day-header">Wed</div>
                    <div class="calendar-day-header">Thu</div>
                    <div class="calendar-day-header">Fri</div>
                    <div class="calendar-day-header">Sat</div>
            `;
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            // Add empty cells for days before month starts
            for (let i = firstDay - 1; i >= 0; i--) {
                const day = daysInPrevMonth - i;
                html += `<div class="calendar-day other-month disabled">${day}</div>`;
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                let classes = 'calendar-day';
                
                // Check if this day is in the past
                const thisDate = new Date(year, month, day);
                const todayDate = new Date();
                todayDate.setHours(0, 0, 0, 0);
                
                if (thisDate < todayDate) {
                    classes += ' past';
                }
                
                // Check if this is the selected date
                if (selectedYear === year && selectedMonth === month + 1) {
                    classes += ' selected';
                }
                
                // Check if this is today
                if (year === today.getFullYear() && month === today.getMonth() && day === today.getDate()) {
                    classes += ' today';
                }
                
                html += `<div class="${classes}" onclick="selectDate('${rowId}', ${year}, ${month + 1}, ${day})">${day}</div>`;
            }
            
            // Add days from next month to fill the grid
            const totalCells = firstDay + daysInMonth;
            const cellsToAdd = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
            for (let day = 1; day <= cellsToAdd; day++) {
                html += `<div class="calendar-day other-month disabled">${day}</div>`;
            }
            
            html += '</div>';
            
            calendarEl.innerHTML = html;
        }
        
        function toggleCalendar(rowId) {
            const calendar = document.getElementById(`calendar-${rowId}`);
            const displayEl = document.getElementById(`date-display-${rowId}`);
            const allCalendars = document.querySelectorAll('.calendar-popup');
            
            // Close all other calendars
            allCalendars.forEach(cal => {
                if (cal.id !== `calendar-${rowId}`) {
                    cal.classList.remove('show');
                }
            });
            
            // Toggle current calendar
            const isShowing = calendar.classList.contains('show');
            
            if (!isShowing) {
                // Get the exact position of the date display element
                const rect = displayEl.getBoundingClientRect();
                
                // Calculate position - directly below the input
                let top = rect.bottom + 5;
                let left = rect.left;
                
                const calendarHeight = 380;
                const calendarWidth = 320;
                
                // Check if calendar would go off bottom of viewport
                if (rect.bottom + calendarHeight > window.innerHeight - 20) {
                    // Position above the input instead
                    top = rect.top - calendarHeight - 5;
                    
                    // If it would go off the top of the screen, position it at the top with some margin
                    if (top < 10) {
                        top = 10;
                    }
                }
                
                // Check if calendar would go off right edge
                if (rect.left + calendarWidth > window.innerWidth - 20) {
                    left = window.innerWidth - calendarWidth - 20;
                }

                // Apply the calculated position
                calendar.style.top = top + 'px';
                calendar.style.left = left + 'px';

                calendar.classList.add('show');

                // Initialize calendar if not already done
                if (!calendar.innerHTML) {
                    const inputEl = document.getElementById(`date-input-${rowId}`);
                    initializeCalendar(rowId, inputEl.value);
                }
                
                // Add scroll listener to reposition calendar
                const scrollHandler = () => {
                    if (calendar.classList.contains('show')) {
                        const newRect = displayEl.getBoundingClientRect();
                        let newTop = newRect.bottom + 5;
                        
                        if (newRect.bottom + calendarHeight > window.innerHeight - 20) {
                            newTop = newRect.top - calendarHeight - 5;
                            if (newTop < 10) {
                                newTop = 10;
                            }
                        }
                        
                        calendar.style.top = newTop + 'px';
                        calendar.style.left = newRect.left + 'px';
                    }
                };
                
                // Attach scroll listener to the scrollable container
                const scrollContainer = document.querySelector('.extra-payments-list');
                if (scrollContainer) {
                    scrollContainer.addEventListener('scroll', scrollHandler);
                    // Store the handler so we can remove it later
                    calendar.scrollHandler = scrollHandler;
                    calendar.scrollContainer = scrollContainer;
                }
            } else {
                calendar.classList.remove('show');
                
                // Remove scroll listener
                if (calendar.scrollHandler && calendar.scrollContainer) {
                    calendar.scrollContainer.removeEventListener('scroll', calendar.scrollHandler);
                    delete calendar.scrollHandler;
                    delete calendar.scrollContainer;
                }
            }
        }
        
        function toggleStartDateCalendar() {
            const calendar = document.getElementById('startDateCalendar');
            const displayEl = document.getElementById('startDateDisplay');
            const allCalendars = document.querySelectorAll('.calendar-popup');
            
            // Close all other calendars
            allCalendars.forEach(cal => {
                if (cal.id !== 'startDateCalendar') {
                    cal.classList.remove('show');
                }
            });
            
            // Toggle current calendar
            const isShowing = calendar.classList.contains('show');
            
            if (!isShowing) {
                // Get the exact position of the date display element
                const rect = displayEl.getBoundingClientRect();
                
                // Calculate position - directly below the input
                let top = rect.bottom + 5;
                let left = rect.left;
                
                const calendarHeight = 380;
                const calendarWidth = 320;
                
                // Check if calendar would go off bottom of viewport
                if (rect.bottom + calendarHeight > window.innerHeight - 20) {
                    // Position above the input instead
                    top = rect.top - calendarHeight - 5;
                }
                
                // Check if calendar would go off right edge
                if (rect.left + calendarWidth > window.innerWidth - 20) {
                    left = window.innerWidth - calendarWidth - 20;
                }
                
                // Apply the calculated position
                calendar.style.top = top + 'px';
                calendar.style.left = left + 'px';
                
                calendar.classList.add('show');
                
                // Initialize calendar if not already done
                if (!calendar.innerHTML) {
                    initializeStartDateCalendar();
                }
            } else {
                calendar.classList.remove('show');
            }
        }
        
        function initializeStartDateCalendar() {
            const inputEl = document.getElementById('startDate');
            const displayEl = document.getElementById('startDateText');
            
            let currentDate = new Date();
            if (inputEl.value) {
                const [year, month] = inputEl.value.split('-');
                currentDate = new Date(parseInt(year), parseInt(month) - 1);
                displayEl.textContent = formatMonthYear(inputEl.value);
            }
            
            renderStartDateCalendar(currentDate);
        }
        
        function renderStartDateCalendar(date) {
            const calendarEl = document.getElementById('startDateCalendar');
            const inputEl = document.getElementById('startDate');
            
            const year = date.getFullYear();
            const month = date.getMonth();
            const today = new Date();
            
            // Get the selected date from the input
            const selectedValue = inputEl.value;
            let selectedYear = null, selectedMonth = null;
            if (selectedValue) {
                [selectedYear, selectedMonth] = selectedValue.split('-').map(n => parseInt(n));
            }
            
            let html = `
                <div class="calendar-header">
                    <div class="month-year-selector">
                        <select class="month-selector" onchange="changeStartMonth(this.value, ${year})">
            `;
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthNames.forEach((name, i) => {
                html += `<option value="${i}" ${i === month ? 'selected' : ''}>${name}</option>`;
            });
            
            html += `
                        </select>
                        <select class="year-selector" onchange="changeStartMonth(${month}, this.value)">
            `;
            
            // Show years from 2 years ago to 5 years in the future
            const startYear = today.getFullYear() - 2;
            const endYear = today.getFullYear() + 5;
            for (let y = startYear; y <= endYear; y++) {
                html += `<option value="${y}" ${y === year ? 'selected' : ''}>${y}</option>`;
            }
            
            html += `
                        </select>
                    </div>
                    <div class="calendar-nav">
                        <button type="button" onclick="event.stopPropagation(); navigateStartMonth(-1)" style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer;">Prev</button>
                        <button type="button" onclick="event.stopPropagation(); navigateStartMonth(1)" style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer;">Next</button>
                    </div>
                </div>
                <div class="calendar-grid">
                    <div class="calendar-day-header">Sun</div>
                    <div class="calendar-day-header">Mon</div>
                    <div class="calendar-day-header">Tue</div>
                    <div class="calendar-day-header">Wed</div>
                    <div class="calendar-day-header">Thu</div>
                    <div class="calendar-day-header">Fri</div>
                    <div class="calendar-day-header">Sat</div>
            `;
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            // Add empty cells for days before month starts
            for (let i = firstDay - 1; i >= 0; i--) {
                const day = daysInPrevMonth - i;
                html += `<div class="calendar-day other-month disabled">${day}</div>`;
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                let classes = 'calendar-day';
                
                // Check if this is the selected date
                if (selectedYear === year && selectedMonth === month + 1) {
                    classes += ' selected';
                }
                
                // Check if this is today
                if (year === today.getFullYear() && month === today.getMonth() && day === today.getDate()) {
                    classes += ' today';
                }
                
                html += `<div class="${classes}" onclick="selectStartDate(${year}, ${month + 1}, ${day})">${day}</div>`;
            }
            
            // Add days from next month to fill the grid
            const totalCells = firstDay + daysInMonth;
            const cellsToAdd = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
            for (let day = 1; day <= cellsToAdd; day++) {
                html += `<div class="calendar-day other-month disabled">${day}</div>`;
            }
            
            html += '</div>';
            
            calendarEl.innerHTML = html;
        }
        
        function changeStartMonth(month, year) {
            const date = new Date(parseInt(year), parseInt(month));
            renderStartDateCalendar(date);
        }
        
        function navigateStartMonth(direction) {
            const calendarEl = document.getElementById('startDateCalendar');
            const monthSelector = calendarEl.querySelector('.month-selector');
            const yearSelector = calendarEl.querySelector('.year-selector');
            
            let month = parseInt(monthSelector.value);
            let year = parseInt(yearSelector.value);
            
            month += direction;
            if (month < 0) {
                month = 11;
                year--;
            } else if (month > 11) {
                month = 0;
                year++;
            }
            
            const date = new Date(year, month);
            renderStartDateCalendar(date);
        }
        
        function selectStartDate(year, month, day) {
            const inputEl = document.getElementById('startDate');
            const displayEl = document.getElementById('startDateText');
            const calendarEl = document.getElementById('startDateCalendar');
            
            // Format as YYYY-MM
            const monthStr = String(month).padStart(2, '0');
            const dateStr = `${year}-${monthStr}`;
            
            inputEl.value = dateStr;
            displayEl.textContent = formatMonthYear(dateStr);
            calendarEl.classList.remove('show');
            
            // Trigger updates - THIS IS KEY FOR THE WARNING TO WORK
            updateExtraPayments();
            updateAmortizationTable();
        }
        
        function changeMonth(rowId, month, year) {
            const date = new Date(parseInt(year), parseInt(month));
            renderCalendar(rowId, date);
        }
        
        function navigateMonth(rowId, direction) {
            const calendarEl = document.getElementById(`calendar-${rowId}`);
            const monthSelector = calendarEl.querySelector('.month-selector');
            const yearSelector = calendarEl.querySelector('.year-selector');
            
            let month = parseInt(monthSelector.value);
            let year = parseInt(yearSelector.value);
            
            month += direction;
            if (month < 0) {
                month = 11;
                year--;
            } else if (month > 11) {
                month = 0;
                year++;
            }
            
            const date = new Date(year, month);
            renderCalendar(rowId, date);
        }
        
        function selectDate(rowId, year, month, day) {
            const inputEl = document.getElementById(`date-input-${rowId}`);
            const displayEl = document.getElementById(`date-display-${rowId}`);
            const calendarEl = document.getElementById(`calendar-${rowId}`);
            
            // Format as YYYY-MM
            const monthStr = String(month).padStart(2, '0');
            const dateStr = `${year}-${monthStr}`;
            
            inputEl.value = dateStr;
            displayEl.querySelector('span:first-child').textContent = formatMonthYear(dateStr);
            calendarEl.classList.remove('show');
            
            // Trigger update
            updateExtraPayments();
        }
        
        // Close calendars when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.date-picker-wrapper')) {
                document.querySelectorAll('.calendar-popup').forEach(cal => {
                    cal.classList.remove('show');
                });
            }
        });
        
        let scheduleModalRow = null;
        
        function openScheduleModal(button) {
            scheduleModalRow = button.parentElement;
            const modal = document.getElementById('scheduleModal');
            if (!modal) {
                createScheduleModal();
            }
            
            // Get current values from the row
            const dateInput = scheduleModalRow.querySelector('input[type="hidden"]');
            const amountInput = scheduleModalRow.querySelector('input[type="number"]');
            const descInput = scheduleModalRow.querySelector('input[type="text"]');
            
            // Set initial values in the modal (default to row date or global start date)
            const globalStart = document.getElementById('startDate').value || '';
            document.getElementById('scheduleStartDate').value = (dateInput.value || globalStart);
            document.getElementById('scheduleAmount').value = amountInput.value || '';
            document.getElementById('scheduleDescription').value = descInput.value || 'Quarterly bonus';
            
            // Set defaults to quarterly and until debt free
            document.getElementById('scheduleFrequency').value = 'quarterly';
            document.querySelector('input[name="durationOption"][value="until"]').checked = true;
            document.querySelector('input[name="durationOption"][value="count"]').checked = false;
            
            // Trigger the duration option toggle to set up the UI correctly
            toggleDurationOption();
            
            // Update preview
            updateSchedulePreview();
            
            // Show modal
            document.getElementById('scheduleModal').classList.add('show');
            // Focus trap start
            const content = document.querySelector('.schedule-modal-content');
            if (content) {
                content.setAttribute('tabindex', '-1');
                // Prefer focusing the modal date selector for convenience
                const dateBtn = content.querySelector('.date-display');
                (dateBtn || content).focus();
            }
            
            // Ensure modal is scrolled to top when opened
            setTimeout(() => {
                const modalContent = document.querySelector('.schedule-modal-content');
                if (modalContent) {
                    modalContent.scrollTop = 0;
                }
            }, 10);
        }
        
        function createScheduleModal() {
            const modal = document.createElement('div');
            modal.id = 'scheduleModal';
            modal.className = 'schedule-modal';
            
            // Generate a unique ID for the modal's calendar
            const modalCalendarId = 'modal-calendar-' + Date.now();
            
            modal.innerHTML = `
                <div class="schedule-modal-content">
                    <div class="schedule-form">
                        <h3>Schedule Recurring Payments</h3>
                        
                        <div class="schedule-form-group">
                            <label>Start Date:</label>
                            <div class="date-picker-wrapper">
                                <div class="date-display" onclick="toggleCalendar('${modalCalendarId}')" id="date-display-${modalCalendarId}">
                                    <span>Select Month</span>
                                    <span>üìÖ</span>
                                </div>
                                <input type="hidden" id="scheduleStartDate" onchange="updateSchedulePreview()">
                                <div class="calendar-popup" id="calendar-${modalCalendarId}"></div>
                            </div>
                        </div>
                        
                        <div class="schedule-form-group">
                            <label for="scheduleAmount">Amount:</label>
                            <input type="number" id="scheduleAmount" step="10" placeholder="Enter amount" onchange="updateSchedulePreview()">
                        </div>
                        
                        <div class="schedule-form-group">
                            <label for="scheduleDescription">Description:</label>
                            <input type="text" id="scheduleDescription" placeholder="e.g., Quarterly bonus">
                        </div>
                        
                        <div class="schedule-form-group">
                            <label for="scheduleFrequency">Frequency:</label>
                            <select id="scheduleFrequency" onchange="updateSchedulePreview()">
                                <option value="monthly">Every Month</option>
                                <option value="bimonthly">Every 2 Months</option>
                                <option value="quarterly">Every 3 Months (Quarterly)</option>
                                <option value="semiannual">Every 6 Months</option>
                                <option value="annual">Every Year</option>
                                <option value="custom">Custom (X months)</option>
                            </select>
                        </div>
                        
                        <div class="schedule-form-group" id="customIntervalGroup" style="display: none;">
                            <label for="customInterval">Every X Months:</label>
                            <input type="number" id="customInterval" min="1" max="60" value="1" onchange="updateSchedulePreview()">
                        </div>
                        
                        <div class="schedule-form-group">
                            <label>Duration:</label>
                            <div style="display: flex; gap: 15px; align-items: center;">
                                <label style="display: flex; align-items: center; font-weight: normal;">
                                    <input type="radio" name="durationOption" value="count" checked onchange="toggleDurationOption()">
                                    <span style="margin-left: 5px;">Number of payments:</span>
                                </label>
                                <input type="number" id="scheduleOccurrences" min="1" max="100" value="12" onchange="updateSchedulePreview()" style="width: 80px;">
                            </div>
                            <div style="display: flex; gap: 15px; align-items: center; margin-top: 10px;">
                                <label style="display: flex; align-items: center; font-weight: normal;">
                                    <input type="radio" name="durationOption" value="until" onchange="toggleDurationOption()">
                                    <span style="margin-left: 5px;">Until debt free (estimated)</span>
                                </label>
                                <span id="untilDebtFreeMonths" style="color: #718096; font-size: 13px;"></span>
                            </div>
                        </div>
                        
                        <div class="schedule-form-group">
                            <label>Preview:</label>
                            <div class="schedule-preview" id="schedulePreview"></div>
                        </div>
                        
                        <div class="schedule-buttons">
                            <button onclick="closeScheduleModal()">Cancel</button>
                            <button onclick="applySchedule()" class="success">Apply Schedule</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Initialize the modal's calendar
            initializeModalCalendar(modalCalendarId);
            
            // Click outside to close (treat as Cancel)
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeScheduleModal();
            });
            // ESC to close
            document.addEventListener('keydown', (e) => {
                const isOpen = document.getElementById('scheduleModal')?.classList.contains('show');
                if (isOpen && e.key === 'Escape') closeScheduleModal();
            });
            // Add event listener for custom frequency
            document.getElementById('scheduleFrequency').addEventListener('change', function() {
                const customGroup = document.getElementById('customIntervalGroup');
                customGroup.style.display = this.value === 'custom' ? 'block' : 'none';
            });
        }
        
        function initializeModalCalendar(calendarId) {
            const startDateStr = document.getElementById('startDate').value;
            if (startDateStr) {
                const [year, month] = startDateStr.split('-');
                const currentDate = new Date(parseInt(year), parseInt(month) - 1);
                renderModalCalendar(calendarId, currentDate);
            } else {
                renderModalCalendar(calendarId, new Date());
            }
        }
        
        function renderModalCalendar(rowId, date) {
            const calendarEl = document.getElementById(`calendar-${rowId}`);
            const inputEl = document.getElementById('scheduleStartDate');
            
            const year = date.getFullYear();
            const month = date.getMonth();
            const today = new Date();
            
            // Get the selected date from the input
            const selectedValue = inputEl.value;
            let selectedYear = null, selectedMonth = null;
            if (selectedValue) {
                [selectedYear, selectedMonth] = selectedValue.split('-').map(n => parseInt(n));
            }
            
            let html = `
                <div class="calendar-header">
                    <div class="month-year-selector">
                        <select class="month-selector" onchange="changeModalMonth('${rowId}', this.value, ${year})">
            `;
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthNames.forEach((name, i) => {
                html += `<option value="${i}" ${i === month ? 'selected' : ''}>${name}</option>`;
            });
            
            html += `
                        </select>
                        <select class="year-selector" onchange="changeModalMonth('${rowId}', ${month}, this.value)">
            `;
            
            // Show years from 2 years ago to 5 years in the future
            const startYear = today.getFullYear() - 2;
            const endYear = today.getFullYear() + 5;
            for (let y = startYear; y <= endYear; y++) {
                html += `<option value="${y}" ${y === year ? 'selected' : ''}>${y}</option>`;
            }
            
            html += `
                        </select>
                    </div>
                    <div class="calendar-nav">
                        <button type="button" onclick="event.stopPropagation(); navigateModalMonth('${rowId}', -1)" style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer;">Prev</button>
                        <button type="button" onclick="event.stopPropagation(); navigateModalMonth('${rowId}', 1)" style="background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 5px; font-weight: bold; cursor: pointer;">Next</button>
                    </div>
                </div>
                <div class="calendar-grid">
                    <div class="calendar-day-header">Sun</div>
                    <div class="calendar-day-header">Mon</div>
                    <div class="calendar-day-header">Tue</div>
                    <div class="calendar-day-header">Wed</div>
                    <div class="calendar-day-header">Thu</div>
                    <div class="calendar-day-header">Fri</div>
                    <div class="calendar-day-header">Sat</div>
            `;
            
            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();
            
            // Add empty cells for days before month starts
            for (let i = firstDay - 1; i >= 0; i--) {
                const day = daysInPrevMonth - i;
                html += `<div class="calendar-day other-month disabled">${day}</div>`;
            }
            
            // Add days of the month
            for (let day = 1; day <= daysInMonth; day++) {
                let classes = 'calendar-day';
                
                // Check if this is the selected date
                if (selectedYear === year && selectedMonth === month + 1) {
                    classes += ' selected';
                }
                
                // Check if this is today
                if (year === today.getFullYear() && month === today.getMonth() && day === today.getDate()) {
                    classes += ' today';
                }
                
                html += `<div class="${classes}" onclick="selectModalDate('${rowId}', ${year}, ${month + 1}, ${day})">${day}</div>`;
            }
            
            // Add days from next month to fill the grid
            const totalCells = firstDay + daysInMonth;
            const cellsToAdd = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
            for (let day = 1; day <= cellsToAdd; day++) {
                html += `<div class="calendar-day other-month disabled">${day}</div>`;
            }
            
            html += '</div>';
            
            calendarEl.innerHTML = html;
        }
        
        function changeModalMonth(rowId, month, year) {
            const date = new Date(parseInt(year), parseInt(month));
            renderModalCalendar(rowId, date);
        }
        
        function navigateModalMonth(rowId, direction) {
            const calendarEl = document.getElementById(`calendar-${rowId}`);
            const monthSelector = calendarEl.querySelector('.month-selector');
            const yearSelector = calendarEl.querySelector('.year-selector');
            
            let month = parseInt(monthSelector.value);
            let year = parseInt(yearSelector.value);
            
            month += direction;
            if (month < 0) {
                month = 11;
                year--;
            } else if (month > 11) {
                month = 0;
                year++;
            }
            
            const date = new Date(year, month);
            renderModalCalendar(rowId, date);
        }
        
        function selectModalDate(rowId, year, month, day) {
            const inputEl = document.getElementById('scheduleStartDate');
            const displayEl = document.getElementById(`date-display-${rowId}`);
            const calendarEl = document.getElementById(`calendar-${rowId}`);
            
            // Format as YYYY-MM
            const monthStr = String(month).padStart(2, '0');
            const dateStr = `${year}-${monthStr}`;
            
            inputEl.value = dateStr;
            displayEl.querySelector('span:first-child').textContent = formatMonthYear(dateStr);
            calendarEl.classList.remove('show');
            
            // Trigger update
            updateSchedulePreview();
        }
        
        function toggleDurationOption() {
            const selectedOption = document.querySelector('input[name="durationOption"]:checked').value;
            const occurrencesInput = document.getElementById('scheduleOccurrences');
            
            if (selectedOption === 'until') {
                occurrencesInput.disabled = true;
                occurrencesInput.style.opacity = '0.5';
                
                // Calculate estimated months to debt freedom
                const schedule = calculatePayoffSchedule();
                const estimatedMonths = schedule.length;
                
                if (estimatedMonths > 0) {
                    document.getElementById('untilDebtFreeMonths').textContent = 
                        `(~${estimatedMonths} months based on current plan)`;
                    occurrencesInput.value = Math.min(estimatedMonths, 100);
                } else {
                    document.getElementById('untilDebtFreeMonths').textContent = 
                        '(calculating...)';
                    occurrencesInput.value = 36; // Default fallback
                }
            } else {
                occurrencesInput.disabled = false;
                occurrencesInput.style.opacity = '1';
                occurrencesInput.value = 12; // Reset to default
            }
            
            updateSchedulePreview();
        }
        
        function toggleExtraPaymentsList() {
            const list = document.getElementById('extraPaymentsList');
            const btn = document.querySelector('.expand-collapse-btn');
            
            if (list.classList.contains('collapsed')) {
                list.classList.remove('collapsed');
                btn.textContent = 'Collapse';
            } else {
                list.classList.add('collapsed');
                btn.textContent = 'Show All';
            }
        }
        
        function updateExtraPaymentsSummary() {
            const rows = document.querySelectorAll('.extra-payment-row');
            const summary = document.getElementById('extraPaymentsSummary');
            const summaryText = document.getElementById('extraPaymentsSummaryText');
            const list = document.getElementById('extraPaymentsList');
            
            if (rows.length > 5) {
                summary.style.display = 'flex';
                
                // Calculate total amount
                let totalAmount = 0;
                rows.forEach(row => {
                    const amountInput = row.querySelector('input[type="number"]');
                    if (amountInput && amountInput.value) {
                        totalAmount += parseFloat(amountInput.value);
                    }
                });
                
                summaryText.textContent = `${rows.length} extra payments scheduled (Total: ${formatCurrency(totalAmount)})`;
                
                // Auto-collapse if more than 5 payments
                if (!list.classList.contains('collapsed')) {
                    list.classList.add('collapsed');
                    document.querySelector('.expand-collapse-btn').textContent = 'Show All';
                }
            } else {
                summary.style.display = 'none';
                list.classList.remove('collapsed');
            }
        }
        
        function updateSchedulePreview() {
            const startDate = document.getElementById('scheduleStartDate').value;
            const amount = document.getElementById('scheduleAmount').value;
            const frequency = document.getElementById('scheduleFrequency').value;
            const occurrences = parseInt(document.getElementById('scheduleOccurrences').value) || 0;
            const customInterval = parseInt(document.getElementById('customInterval').value) || 1;
            
            const preview = document.getElementById('schedulePreview');
            
            if (!startDate || !amount || occurrences === 0) {
                preview.innerHTML = '<em>Enter values to see preview</em>';
                return;
            }
            
            let interval;
            switch (frequency) {
                case 'monthly': interval = 1; break;
                case 'bimonthly': interval = 2; break;
                case 'quarterly': interval = 3; break;
                case 'semiannual': interval = 6; break;
                case 'annual': interval = 12; break;
                case 'custom': interval = customInterval; break;
            }
            
            const [year, month] = startDate.split('-').map(n => parseInt(n));
            let html = '';
            let totalAmount = 0;
            
            for (let i = 0; i < Math.min(occurrences, 12); i++) {
                const paymentDate = new Date(year, month - 1 + (i * interval));
                const dateStr = paymentDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                html += `<div class="schedule-preview-item">
                    <span>${dateStr}</span>
                    <span>${formatCurrency(parseFloat(amount))}</span>
                </div>`;
                totalAmount += parseFloat(amount);
            }
            
            if (occurrences > 12) {
                html += `<div style="text-align: center; color: #718096; padding: 10px;">
                    ... and ${occurrences - 12} more payments ...
                </div>`;
                totalAmount = parseFloat(amount) * occurrences;
            }
            
            html += `<div style="border-top: 2px solid #e2e8f0; margin-top: 10px; padding-top: 10px; font-weight: bold;">
                Total: ${formatCurrency(totalAmount)} over ${occurrences} payments
            </div>`;
            
            preview.innerHTML = html;
        }
        
        function closeScheduleModal() {
            document.getElementById('scheduleModal').classList.remove('show');
            scheduleModalRow = null;
            persistToLocalStorage();
        }
        
        function applySchedule() {
            const startDate = document.getElementById('scheduleStartDate').value;
            const amount = document.getElementById('scheduleAmount').value;
            const description = document.getElementById('scheduleDescription').value;
            const frequency = document.getElementById('scheduleFrequency').value;
            const durationOption = document.querySelector('input[name="durationOption"]:checked').value;
            let occurrences = parseInt(document.getElementById('scheduleOccurrences').value);
            const customInterval = parseInt(document.getElementById('customInterval').value) || 1;
            
            if (!startDate || !amount || !occurrences) {
                alert('Please fill in all required fields');
                return;
            }
            
            // If "until debt free" is selected, get the calculated number
            if (durationOption === 'until') {
                const schedule = calculatePayoffSchedule();
                occurrences = Math.min(schedule.length || 36, 100); // Cap at 100 payments max
            }
            
            let interval;
            switch (frequency) {
                case 'monthly': interval = 1; break;
                case 'bimonthly': interval = 2; break;
                case 'quarterly': interval = 3; break;
                case 'semiannual': interval = 6; break;
                case 'annual': interval = 12; break;
                case 'custom': interval = customInterval; break;
            }
            
            const [year, month] = startDate.split('-').map(n => parseInt(n));
            const container = document.getElementById('extraPaymentsList');
            
            // Remove the current row (it will be replaced with scheduled payments)
            if (scheduleModalRow) {
                scheduleModalRow.remove();
            }
            
            // Calculate how many payments will actually apply before debt is paid off
            const currentSchedule = calculatePayoffSchedule();
            const debtFreeMonth = currentSchedule.length;
            
            // Add all scheduled payments
            let addedCount = 0;
            for (let i = 0; i < occurrences; i++) {
                const paymentDate = new Date(year, month - 1 + (i * interval));
                const paymentYear = paymentDate.getFullYear();
                const paymentMonth = String(paymentDate.getMonth() + 1).padStart(2, '0');
                const dateStr = `${paymentYear}-${paymentMonth}`;
                
                // Calculate which month this will be in the schedule
                const startDateStr = document.getElementById('startDate').value;
                if (startDateStr) {
                    const [startYear, startMonth] = startDateStr.split('-').map(n => parseInt(n));
                    const monthsDiff = (paymentYear - startYear) * 12 + (parseInt(paymentMonth) - startMonth);
                    const monthNumber = monthsDiff + 1;
                    
                    // Only add if it's before estimated debt payoff (with some buffer)
                    if (durationOption === 'until' && monthNumber > debtFreeMonth + 3) {
                        break; // Stop adding payments after debt is paid
                    }
                }
                
                addExtraPayment({
                    displayDate: dateStr,
                    amount: amount,
                    description: description + (occurrences > 1 ? ` (${i + 1}/${occurrences})` : '')
                });
                addedCount++;
            }
            
            // Show warning if payments extend beyond debt payoff
            if (durationOption === 'count' && debtFreeMonth > 0 && addedCount > 0) {
                const lastPaymentIndex = addedCount - 1;
                const lastPaymentDate = new Date(year, month - 1 + (lastPaymentIndex * interval));
                const [startYear, startMonth] = document.getElementById('startDate').value.split('-').map(n => parseInt(n));
                const monthsDiff = (lastPaymentDate.getFullYear() - startYear) * 12 + 
                                 (lastPaymentDate.getMonth() + 1 - startMonth);
                const lastPaymentMonth = monthsDiff + 1;
                
                if (lastPaymentMonth > debtFreeMonth) {
                    showWarning(`Note: Some scheduled payments extend beyond your estimated debt-free date (month ${debtFreeMonth}). These extra payments will accelerate your payoff further.`);
                }
            }
            
            // Update and close
            updateExtraPayments();
            closeScheduleModal();
        }

        function duplicateExtraPayment(button) {
            const row = button.parentElement;
            const dateInput = row.querySelector('input[type="hidden"]');
            const amountInput = row.querySelector('input[type="number"]');
            const descInput = row.querySelector('input[type="text"]');
            
            const payment = {
                displayDate: dateInput ? dateInput.value : '',
                amount: amountInput ? amountInput.value : '',
                description: descInput ? descInput.value : ''
            };
            addExtraPayment(payment);
            updateExtraPayments();
        }

        function removeExtraPayment(button) {
            button.parentElement.remove();
            updateExtraPayments();
        }

        function updateExtraPayments() {
            extraPayments = [];
            const debugInfo = document.getElementById('debugInfo');
            let debugText = 'Extra Payments Debug:\n';

            document.querySelectorAll('.extra-payment-row').forEach(row => {
                const inputs = row.querySelectorAll('input');
                const warningSpan = row.querySelector('.before-start-warning');

                // Remove any existing before-start styling
                row.classList.remove('before-start');
                if (warningSpan) {
                    warningSpan.style.display = 'none';
                }

                if (inputs[0].value && inputs[1].value) {
                    const startDateStr = document.getElementById('startDate').value;
                    if (startDateStr) {
                        // Parse the dates more carefully
                        const [extraYear, extraMonth] = inputs[0].value.split('-').map(n => parseInt(n));
                        const [startYear, startMonth] = startDateStr.split('-').map(n => parseInt(n));

                        // Calculate the difference in months
                        const monthsDiff = (extraYear - startYear) * 12 + (extraMonth - startMonth);

                        // Month 1 is the start month, so monthsDiff of 0 = month 1
                        const monthNumber = monthsDiff + 1;

                        debugText += `Date: ${inputs[0].value}, Amount: ${inputs[1].value}, Calculated Month: ${monthNumber}`;

                        if (monthNumber <= 0) {
                            // Payment is before start date - apply visual warning
                            row.classList.add('before-start');
                            if (warningSpan) {
                                warningSpan.style.display = 'inline';
                            }
                            debugText += ' [IGNORED - Before Start]\n';
                        } else {
                            // Payment is valid - add to calculations
                            extraPayments.push({
                                month: monthNumber,
                                amount: parseFloat(inputs[1].value),
                                description: inputs[2].value || '',
                                displayDate: inputs[0].value
                            });
                            debugText += '\n';
                        }
                    } else {
                        debugText += `Date: ${inputs[0].value}, Amount: ${inputs[1].value}, No start date set\n`;
                    }
                }
            });
            
            // Show debug info if there are extra payments
            if (extraPayments.length > 0) {
                debugInfo.textContent = debugText;
                debugInfo.style.display = 'block';
            } else {
                debugInfo.style.display = 'none';
            }
            
            console.log('Extra Payments:', extraPayments);
            persistToLocalStorage();
            if (window._recalcTimer) clearTimeout(window._recalcTimer);
            window._recalcTimer = setTimeout(() => updateAmortizationTable(), 150);
        }

        function removeAllExtraPayments() {
            if (!confirm('Remove all scheduled extra payments?')) return;
            extraPayments = [];
            const container = document.getElementById('extraPaymentsList');
            container.innerHTML = '';
            addExtraPayment();
            updateExtraPayments();
        }

        function getPhaseThresholdText(phase) {
            if (!phase) return '';
            
            if (phase.includes('Emergency Recovery')) {
                return ' ‚Üí Target: <89%';
            } else if (phase.includes('Critical Threshold')) {
                return ' ‚Üí Target: <49%';
            } else if (phase.includes('Good Standing')) {
                return ' ‚Üí Target: <29%';
            } else if (phase.includes('Premium Qualification')) {
                return ' ‚Üí Target: <10% overall';
            } else if (phase.includes('AZEO')) {
                return ' ‚Üí Target: 1 card at 1-9%';
            }
            return '';
        }
        
        function determineWaterfallPhase(activeDebts) {
            const creditCards = activeDebts.filter(d => !d.paidOff && d.creditLimit && d.creditLimit > 0);
            
            if (creditCards.length === 0) {
                return { 
                    phase: 'Complete', 
                    phaseNumber: 6,
                    progress: 100,
                    description: 'All debts paid off'
                };
            }
            
            const totalCreditLimit = creditCards.reduce((sum, d) => sum + d.creditLimit, 0);
            const totalCreditBalance = creditCards.reduce((sum, d) => sum + d.currentBalance, 0);
            const overallUtil = totalCreditLimit > 0 ? (totalCreditBalance / totalCreditLimit) * 100 : 0;
            
            // Check for Phase 1: Emergency Recovery (89% threshold)
            const over89Cards = creditCards.filter(d => (d.currentBalance / d.creditLimit) * 100 > 89);
            if (over89Cards.length > 0) {
                const progress = ((creditCards.length - over89Cards.length) / creditCards.length) * 100;
                return { 
                    phase: 'Phase 1: Emergency Recovery',
                    phaseNumber: 1,
                    progress: Math.round(progress),
                    description: `Getting ${over89Cards.length} card(s) below 89% utilization`,
                    cardsAboveThreshold: over89Cards.length,
                    threshold: 89
                };
            }
            
            // Check for Phase 2: Critical Threshold (49%)
            const over49Cards = creditCards.filter(d => (d.currentBalance / d.creditLimit) * 100 > 49);
            if (over49Cards.length > 0) {
                const progress = ((creditCards.length - over49Cards.length) / creditCards.length) * 100;
                return { 
                    phase: 'Phase 2: Critical Threshold',
                    phaseNumber: 2,
                    progress: Math.round(progress),
                    description: `Getting ${over49Cards.length} card(s) below 49% utilization`,
                    cardsAboveThreshold: over49Cards.length,
                    threshold: 49
                };
            }
            
            // Check for Phase 3: Good Standing (29%)
            const over29Cards = creditCards.filter(d => (d.currentBalance / d.creditLimit) * 100 > 29);
            if (over29Cards.length > 0) {
                const progress = ((creditCards.length - over29Cards.length) / creditCards.length) * 100;
                return { 
                    phase: 'Phase 3: Good Standing',
                    phaseNumber: 3,
                    progress: Math.round(progress),
                    description: `Getting ${over29Cards.length} card(s) below 29% utilization`,
                    cardsAboveThreshold: over29Cards.length,
                    threshold: 29
                };
            }
            
            // Check for Phase 4: Premium Qualification (10% overall)
            if (overallUtil > 10) {
                const progress = Math.max(0, Math.round((1 - (overallUtil - 10) / 20) * 100));
                return { 
                    phase: 'Phase 4: Premium Qualification',
                    phaseNumber: 4,
                    progress: progress,
                    description: `Reducing overall utilization to under 10% (currently ${overallUtil.toFixed(1)}%)`,
                    overallUtilization: overallUtil
                };
            }
            
            // Phase 5: AZEO Optimization
            const cardsWithBalance = creditCards.filter(d => d.currentBalance > 0);
            if (cardsWithBalance.length > 1) {
                return { 
                    phase: 'Phase 5: AZEO Optimization',
                    phaseNumber: 5,
                    progress: Math.round((1 - (cardsWithBalance.length - 1) / creditCards.length) * 100),
                    description: 'Optimizing for All Zero Except One',
                    cardsWithBalance: cardsWithBalance.length
                };
            } else if (cardsWithBalance.length === 1) {
                const singleCard = cardsWithBalance[0];
                const utilization = (singleCard.currentBalance / singleCard.creditLimit) * 100;
                if (utilization >= 1 && utilization <= 9) {
                    return { 
                        phase: 'Phase 5: AZEO Complete',
                        phaseNumber: 5,
                        progress: 100,
                        description: 'AZEO optimization achieved - one card at optimal utilization',
                        optimalCard: singleCard.name
                    };
                } else {
                    return { 
                        phase: 'Phase 5: AZEO Optimization',
                        phaseNumber: 5,
                        progress: 90,
                        description: `Adjusting last card to 1-9% utilization (currently ${utilization.toFixed(1)}%)`,
                        currentUtilization: utilization
                    };
                }
            }
            
            // All cards at zero
            return { 
                phase: 'Complete',
                phaseNumber: 6,
                progress: 100,
                description: 'All credit cards paid off'
            };
        }

        function calculatePayoffSchedule(debtList = null, sortMethod = currentMethod) {
            try {
                let workingDebts = debtList ? JSON.parse(JSON.stringify(debtList)) : JSON.parse(JSON.stringify(debts));
                
                // For credit score method, we don't sort initially - we handle priority dynamically
                if (sortMethod !== 'utilization') {
                    workingDebts = sortDebtsCopy(workingDebts, sortMethod);
                }
                
                const schedule = [];
                let month = 0;
                const totalMin = workingDebts.reduce((sum, d) => sum + (d.minPayment || 0), 0);
                
                // Check if payment is less than minimum required
                if (totalMonthlyPayment < totalMin) {
                    return []; // Return empty schedule - can't pay off debts without meeting minimums
                }
                
                let baseExtra = Math.max(0, totalMonthlyPayment - totalMin);
                
                const debtPayoffMonths = {};
                
                let activeDebts = workingDebts.map(d => ({
                    ...d,
                    currentBalance: d.balance,
                    paidOff: false,
                    originalMinPayment: d.minPayment,
                    targetReached: false // For credit score method
                }));
                
                // Safety check for impossible payoff scenarios
                const totalMonthlyInterest = activeDebts.reduce((sum, d) => 
                    sum + calculateMonthlyInterest(d.balance, d.rate), 0);
                
                if (totalMonthlyPayment <= totalMonthlyInterest) {
                    return [];
                }
                
                console.log('=== Starting payoff calculation ===');
                console.log('Base extra per month:', formatCurrency(baseExtra));
                console.log('Extra payments scheduled:', extraPayments);
                
                while (activeDebts.some(d => !d.paidOff) && month < 600) {
                    month++;
                    const monthData = {
                        month: month,
                        payments: {},
                        balances: {},
                        interest: {},
                        extra: 0,
                        snowballAmount: {}
                    };
                    
                    // Find all extra payments for this specific month
                    const extraPaymentsThisMonth = extraPayments.filter(p => p.month === month);
                    const extraThisMonth = extraPaymentsThisMonth.reduce((sum, p) => sum + p.amount, 0);
                    
                    // Total available extra = base extra + scheduled extra payments
                    let availableExtra = baseExtra + extraThisMonth;
                    
                    // Store the scheduled extra payment amount for display
                    monthData.extra = extraThisMonth;
                    
                    if (month <= 5 || extraThisMonth > 0) {
                        console.log(`Month ${month}: Base extra: ${formatCurrency(baseExtra)}, Extra payments: ${formatCurrency(extraThisMonth)}, Total available: ${formatCurrency(availableExtra)}`);
                        if (extraPaymentsThisMonth.length > 0) {
                            console.log('  Extra payment details:', extraPaymentsThisMonth);
                        }
                    }
                    
                    // Add interest
                    activeDebts.forEach(debt => {
                        if (!debt.paidOff) {
                            const monthlyInterest = calculateMonthlyInterest(debt.currentBalance, debt.rate);
                            monthData.interest[debt.name] = monthlyInterest;
                            debt.currentBalance += monthlyInterest;
                        } else {
                            monthData.interest[debt.name] = 0;
                        }
                    });
                    
                    // Make payments
                    if (sortMethod === 'utilization') {
                        // Waterfall Credit Score Method - sophisticated phase-based approach
                        
                        // First, make minimum payments on all debts
                        activeDebts.forEach(debt => {
                            if (debt.paidOff) {
                                monthData.payments[debt.name] = 0;
                                monthData.balances[debt.name] = 0;
                                monthData.snowballAmount[debt.name] = 0;
                            } else {
                                const payment = Math.min(debt.originalMinPayment, debt.currentBalance);
                                monthData.payments[debt.name] = payment;
                                monthData.snowballAmount[debt.name] = 0;
                                debt.currentBalance -= payment;
                                
                                if (debt.currentBalance <= 0.01) {
                                    debt.currentBalance = 0;
                                    debt.paidOff = true;
                                    debtPayoffMonths[debt.name] = month;
                                    baseExtra += debt.originalMinPayment;
                                }
                            }
                        });
                        
                        // Determine current phase and calculate phase information
                        const phaseInfo = determineWaterfallPhase(activeDebts);
                        monthData.phase = phaseInfo.phase;
                        monthData.phaseProgress = phaseInfo.progress;
                        
                        // Apply extra payment according to waterfall strategy
                        while (availableExtra > 0.01 && activeDebts.some(d => !d.paidOff)) {
                            let targetDebt = null;
                            let targetThreshold = null;
                            
                            const unpaidDebts = activeDebts.filter(d => !d.paidOff);
                            const creditCards = unpaidDebts.filter(d => d.creditLimit && d.creditLimit > 0);
                            
                            // Phase 1: Emergency Recovery - Get all cards below 89%
                            const over89Cards = creditCards.filter(d => {
                                const util = (d.currentBalance / d.creditLimit) * 100;
                                return util > 89;
                            }).sort((a, b) => {
                                const utilA = (a.currentBalance / a.creditLimit) * 100;
                                const utilB = (b.currentBalance / b.creditLimit) * 100;
                                return utilB - utilA;
                            });
                            
                            if (over89Cards.length > 0) {
                                targetDebt = over89Cards[0];
                                targetThreshold = 89;
                                const targetBalance = targetDebt.creditLimit * 0.89;
                                const amountNeeded = Math.max(0, targetDebt.currentBalance - targetBalance);
                                const extraPayment = Math.min(availableExtra, amountNeeded);
                                
                                if (extraPayment > 0) {
                                    monthData.payments[targetDebt.name] += extraPayment;
                                    monthData.snowballAmount[targetDebt.name] += extraPayment;
                                    targetDebt.currentBalance -= extraPayment;
                                    availableExtra -= extraPayment;
                                    continue;
                                }
                            }
                            
                            // Phase 2: Critical Threshold - Get all cards below 49%
                            if (availableExtra > 0.01 && !targetDebt) {
                                const over49Cards = creditCards.filter(d => {
                                    const util = (d.currentBalance / d.creditLimit) * 100;
                                    return util > 49;
                                }).sort((a, b) => {
                                    const utilA = (a.currentBalance / a.creditLimit) * 100;
                                    const utilB = (b.currentBalance / b.creditLimit) * 100;
                                    return utilB - utilA;
                                });
                                
                                if (over49Cards.length > 0) {
                                    targetDebt = over49Cards[0];
                                    targetThreshold = 49;
                                    const targetBalance = targetDebt.creditLimit * 0.49;
                                    const amountNeeded = Math.max(0, targetDebt.currentBalance - targetBalance);
                                    const extraPayment = Math.min(availableExtra, amountNeeded);
                                    
                                    if (extraPayment > 0) {
                                        monthData.payments[targetDebt.name] += extraPayment;
                                        monthData.snowballAmount[targetDebt.name] += extraPayment;
                                        targetDebt.currentBalance -= extraPayment;
                                        availableExtra -= extraPayment;
                                        continue;
                                    }
                                }
                            }
                            
                            // Phase 3: Good Standing - Get all cards below 29%
                            if (availableExtra > 0.01 && !targetDebt) {
                                const over29Cards = creditCards.filter(d => {
                                    const util = (d.currentBalance / d.creditLimit) * 100;
                                    return util > 29;
                                }).sort((a, b) => {
                                    const utilA = (a.currentBalance / a.creditLimit) * 100;
                                    const utilB = (b.currentBalance / b.creditLimit) * 100;
                                    return utilB - utilA;
                                });
                                
                                if (over29Cards.length > 0) {
                                    targetDebt = over29Cards[0];
                                    targetThreshold = 29;
                                    const targetBalance = targetDebt.creditLimit * 0.29;
                                    const amountNeeded = Math.max(0, targetDebt.currentBalance - targetBalance);
                                    const extraPayment = Math.min(availableExtra, amountNeeded);
                                    
                                    if (extraPayment > 0) {
                                        monthData.payments[targetDebt.name] += extraPayment;
                                        monthData.snowballAmount[targetDebt.name] += extraPayment;
                                        targetDebt.currentBalance -= extraPayment;
                                        availableExtra -= extraPayment;
                                        continue;
                                    }
                                }
                            }
                            
                            // Phase 4: Premium Qualification - Reduce overall utilization to under 10%
                            if (availableExtra > 0.01 && !targetDebt) {
                                const totalCreditLimit = creditCards.reduce((sum, d) => sum + d.creditLimit, 0);
                                const totalCreditBalance = creditCards.reduce((sum, d) => sum + d.currentBalance, 0);
                                const overallUtil = totalCreditLimit > 0 ? (totalCreditBalance / totalCreditLimit) * 100 : 0;
                                
                                if (overallUtil > 10) {
                                    // Pay down highest balance cards first for maximum impact on overall utilization
                                    const sortedByBalance = creditCards
                                        .filter(d => d.currentBalance > 0)
                                        .sort((a, b) => b.currentBalance - a.currentBalance);
                                    
                                    if (sortedByBalance.length > 0) {
                                        targetDebt = sortedByBalance[0];
                                        const extraPayment = Math.min(availableExtra, targetDebt.currentBalance);
                                        
                                        if (extraPayment > 0) {
                                            monthData.payments[targetDebt.name] += extraPayment;
                                            monthData.snowballAmount[targetDebt.name] += extraPayment;
                                            targetDebt.currentBalance -= extraPayment;
                                            availableExtra -= extraPayment;
                                            continue;
                                        }
                                    }
                                }
                            }
                            
                            // Phase 5: AZEO (All Zero Except One) - Keep one card at 1-9%, rest at 0%
                            if (availableExtra > 0.01 && !targetDebt) {
                                const cardsWithBalance = creditCards.filter(d => d.currentBalance > 0);
                                
                                if (cardsWithBalance.length > 1) {
                                    // Pay off all but the smallest balance card
                                    const sortedByBalance = cardsWithBalance.sort((a, b) => a.currentBalance - b.currentBalance);
                                    const smallestCard = sortedByBalance[0];
                                    const targetUtil = (smallestCard.currentBalance / smallestCard.creditLimit) * 100;
                                    
                                    // If smallest card is already at 1-9%, pay others
                                    if (targetUtil >= 1 && targetUtil <= 9 && sortedByBalance.length > 1) {
                                        targetDebt = sortedByBalance[1];
                                    } else if (targetUtil > 9) {
                                        // Bring smallest card down to 9%
                                        targetDebt = smallestCard;
                                        const targetBalance = smallestCard.creditLimit * 0.09;
                                        const amountNeeded = Math.max(0, smallestCard.currentBalance - targetBalance);
                                        const extraPayment = Math.min(availableExtra, amountNeeded);
                                        
                                        if (extraPayment > 0) {
                                            monthData.payments[targetDebt.name] += extraPayment;
                                            monthData.snowballAmount[targetDebt.name] += extraPayment;
                                            targetDebt.currentBalance -= extraPayment;
                                            availableExtra -= extraPayment;
                                            continue;
                                        }
                                    } else if (sortedByBalance.length > 1) {
                                        // Pay other cards
                                        targetDebt = sortedByBalance[1];
                                    }
                                    
                                    if (targetDebt) {
                                        const extraPayment = Math.min(availableExtra, targetDebt.currentBalance);
                                        
                                        if (extraPayment > 0) {
                                            monthData.payments[targetDebt.name] += extraPayment;
                                            monthData.snowballAmount[targetDebt.name] += extraPayment;
                                            targetDebt.currentBalance -= extraPayment;
                                            availableExtra -= extraPayment;
                                            continue;
                                        }
                                    }
                                }
                            }
                            
                            // Final fallback: Pay any remaining debts (loans) using avalanche
                            if (availableExtra > 0.01 && !targetDebt) {
                                const remainingDebts = unpaidDebts.sort((a, b) => b.rate - a.rate);
                                
                                if (remainingDebts.length > 0) {
                                    targetDebt = remainingDebts[0];
                                    const extraPayment = Math.min(availableExtra, targetDebt.currentBalance);
                                    
                                    if (extraPayment > 0) {
                                        monthData.payments[targetDebt.name] += extraPayment;
                                        monthData.snowballAmount[targetDebt.name] += extraPayment;
                                        targetDebt.currentBalance -= extraPayment;
                                        availableExtra -= extraPayment;
                                    }
                                }
                            }
                            
                            // Check if any debt was paid off
                            activeDebts.forEach(debt => {
                                if (!debt.paidOff && debt.currentBalance <= 0.01) {
                                    debt.currentBalance = 0;
                                    debt.paidOff = true;
                                    debtPayoffMonths[debt.name] = month;
                                    baseExtra += debt.originalMinPayment;
                                }
                            });
                            
                            // Break if no progress was made
                            if (!targetDebt) break;
                        }
                        
                        // Update balances in monthData
                        activeDebts.forEach(debt => {
                            monthData.balances[debt.name] = Math.max(0, debt.currentBalance);
                        });
                        
                    } else {
                        // Standard snowball/avalanche/cfi/custom method
                        activeDebts.forEach(debt => {
                            if (debt.paidOff) {
                                monthData.payments[debt.name] = 0;
                                monthData.balances[debt.name] = 0;
                                monthData.snowballAmount[debt.name] = 0;
                                return;
                            }
                            
                            // Make minimum payment
                            let payment = Math.min(debt.originalMinPayment, debt.currentBalance);
                            monthData.payments[debt.name] = payment;
                            monthData.snowballAmount[debt.name] = 0;
                            debt.currentBalance -= payment;
                            
                            if (debt.currentBalance <= 0.01) {
                                debt.currentBalance = 0;
                                debt.paidOff = true;
                                debtPayoffMonths[debt.name] = month;
                                baseExtra += debt.originalMinPayment;
                            }
                        });
                        
                        // Now apply extra payment, cascading to next debt if current is paid off
                        while (availableExtra > 0.01) {
                            const firstUnpaid = activeDebts.find(d => !d.paidOff);
                            if (!firstUnpaid) break;
                            
                            const extraPayment = Math.min(availableExtra, firstUnpaid.currentBalance);
                            monthData.payments[firstUnpaid.name] += extraPayment;
                            monthData.snowballAmount[firstUnpaid.name] += extraPayment;
                            firstUnpaid.currentBalance -= extraPayment;
                            availableExtra -= extraPayment;
                            
                            if (firstUnpaid.currentBalance <= 0.01) {
                                firstUnpaid.currentBalance = 0;
                                firstUnpaid.paidOff = true;
                                debtPayoffMonths[firstUnpaid.name] = month;
                                baseExtra += firstUnpaid.originalMinPayment;
                            }
                        }
                        
                        // Update balances
                        activeDebts.forEach(debt => {
                            monthData.balances[debt.name] = Math.max(0, debt.currentBalance);
                        });
                    }
                    
                    schedule.push(monthData);
                }
                
                schedule.debtPayoffMonths = debtPayoffMonths;
                return schedule;
                
            } catch (error) {
                console.error('Error calculating payoff schedule:', error);
                return [];
            }
        }

        function updateAmortizationTable(showFull = false) {
            try {
                const schedule = calculatePayoffSchedule();
                
                if (schedule.length === 0) {
                    document.getElementById('amortizationHeader').innerHTML = '<th>No schedule available - check that monthly payment exceeds total interest</th>';
                    document.getElementById('amortizationBody').innerHTML = '';
                    return;
                }
                
                const header = document.getElementById('amortizationHeader');
                const body = document.getElementById('amortizationBody');
                const controlsDiv = document.getElementById('scheduleControls');
                
                // Clear the body first
                body.innerHTML = '';
                
                // Set up control row above the table
                controlsDiv.style.display = 'block';
                if (currentMethod === 'utilization') {
                    controlsDiv.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button onclick="openScheduleInPopup()" style="background: transparent; 
                                    border: none; cursor: pointer; padding: 0;"
                                    title="Open in new window">
                                <span style="display: inline-block; width: 24px; height: 24px; background: #4c51bf; color: white; border-radius: 4px; font-size: 14px; line-height: 24px; text-align: center; font-weight: bold;">‚Üó</span>
                            </button>
                            <button onclick="updateSimplifiedWaterfallView()" style="padding: 8px 16px; 
                                    background: #4c51bf; 
                                    color: white; border: none; 
                                    border-radius: 5px; cursor: pointer; font-weight: bold;">
                                üìà Show Simplified Waterfall View
                            </button>
                            <span style="color: #a0aec0; font-size: 14px;">
                                Focus on utilization changes and phase progression
                            </span>
                        </div>
                    `;
                } else {
                    controlsDiv.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <button onclick="openScheduleInPopup()" style="background: transparent; 
                                    border: none; cursor: pointer; padding: 0;"
                                    title="Open in new window">
                                <span style="display: inline-block; width: 24px; height: 24px; background: #4c51bf; color: white; border-radius: 4px; font-size: 14px; line-height: 24px; text-align: center; font-weight: bold;">‚Üó</span>
                            </button>
                            <span style="color: #a0aec0; font-size: 14px;">
                                ${currentMethod.charAt(0).toUpperCase() + currentMethod.slice(1)} Method Payoff Schedule
                            </span>
                        </div>
                    `;
                }
                
                // Now set the headers AFTER the control row
                header.innerHTML = '<th>Month</th><th>Date</th><th>Extra</th>';
                debts.forEach(debt => {
                    const escapedName = escapeHtml(debt.name);
                    header.innerHTML += `<th colspan="3">${escapedName}</th>`;
                });
                header.innerHTML += '<th colspan="4" class="totals-header" style="background: #4a5568;">TOTALS</th>';
                
                const subHeaderRow = body.insertRow();
                subHeaderRow.innerHTML = '<td></td><td></td><td></td>';
                debts.forEach(() => {
                    subHeaderRow.innerHTML += '<td class="totals-subheader-cell"><strong>Payment</strong></td><td class="totals-subheader-cell"><strong>Interest</strong></td><td class="totals-subheader-cell"><strong>Balance</strong></td>';
                });
                subHeaderRow.innerHTML += `<td class="totals-subheader-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#4a5568', '#e2e8f0')};"><strong>Payment</strong></td><td class="totals-subheader-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#4a5568', '#e2e8f0')};"><strong>Interest</strong></td><td class="totals-subheader-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#4a5568', '#e2e8f0')};"><strong>Principal</strong></td><td class="totals-subheader-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#4a5568', '#e2e8f0')};"><strong>Balance</strong></td>`;
                
                let rowsToShow = [];
                if (showFull || schedule.length <= 24) {
                    rowsToShow = schedule;
                } else {
                    rowsToShow = [
                        ...schedule.slice(0, 12),
                        { isEllipsis: true, skippedFrom: 13, skippedTo: schedule.length - 3 },
                        ...schedule.slice(-3)
                    ];
                }
                
                let previousPhase = null;
                rowsToShow.forEach((monthData, index) => {
                    if (monthData.isEllipsis) {
                        const row = body.insertRow();
                        row.style.cursor = 'pointer';
                        row.onclick = () => updateAmortizationTable(true);
                        row.innerHTML = `<td colspan="100%" class="schedule-ellipsis schedule-ellipsis-row" style="background: ${getThemeColor('#f0f4f8', '#0f172a')}; padding: 15px; text-align: left; border: 2px solid ${getThemeColor('#e2e8f0', '#1f2937')};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>‚ñ∂</strong> Months ${monthData.skippedFrom}-${monthData.skippedTo} hidden (${monthData.skippedTo - monthData.skippedFrom + 1} months) 
                                    <span style="color: ${getThemeColor('#667eea', '#818cf8')}; margin-left: 10px;">Click anywhere to expand</span>
                                </div>
                                <div>
                                    <button onclick="event.stopPropagation(); exportSimplifiedToCSV()" style="padding: 5px 10px; font-size: 12px;">üì• Simple Export</button>
                                    <button onclick="event.stopPropagation(); exportToCSV()" style="padding: 5px 10px; font-size: 12px;">üìä Detailed Export</button>
                                </div>
                            </div>
                        </td>`;
                        return;
                    }
                    
                    // Check for phase transition (only for waterfall method)
                    if (currentMethod === 'utilization' && monthData.phase && monthData.phase !== previousPhase) {
                        const phaseRow = body.insertRow();
                        phaseRow.innerHTML = `
                            <td colspan="100%" style="background: ${getThemeColor('#e6f2ff', '#1a202c')}; 
                                                      color: ${getThemeColor('#2563eb', '#60a5fa')}; padding: 10px; text-align: center; 
                                                      font-weight: bold; font-size: 14px; 
                                                      border-top: 1px solid ${getThemeColor('#cbd5e1', '#374151')}; border-bottom: 1px solid ${getThemeColor('#cbd5e1', '#374151')};">
                                üéØ ${monthData.phase}${getPhaseThresholdText(monthData.phase)}
                            </td>
                        `;
                        previousPhase = monthData.phase;
                    }
                    
                    const row = body.insertRow();
                    const monthDate = getPayoffDate(monthData.month - 1);
                    row.innerHTML = `<td><strong>${monthData.month}</strong></td>`;
                    row.innerHTML += `<td style="font-size: 11px;">${monthDate}</td>`;
                    row.innerHTML += `<td>${monthData.extra > 0 ? formatCurrency(monthData.extra) : ''}</td>`;
                    
                    let totalPayment = 0;
                    let totalInterest = 0;
                    let totalBalance = 0;
                    
                    debts.forEach(debt => {
                        const payment = monthData.payments[debt.name] || 0;
                        const interest = monthData.interest[debt.name] || 0;
                        const balance = monthData.balances[debt.name] || 0;
                        const snowball = monthData.snowballAmount[debt.name] || 0;
                        
                        totalPayment += payment;
                        totalInterest += interest;
                        totalBalance += balance;
                        
                        const isPaidOff = balance === 0;
                        const isCurrentFocus = !isPaidOff && payment > debt.minPayment;
                        
                        let paymentCell = formatCurrency(payment);
                        if (snowball > 0) {
                            paymentCell += `<br><span class="extra-in-payment">+${formatCurrency(snowball)} extra</span>`;
                        }
                        
                        row.innerHTML += `
                            <td class="${isPaidOff ? 'paid-off' : ''} ${isCurrentFocus ? 'current-focus' : ''}">${paymentCell}</td>
                            <td>${formatCurrency(interest)}</td>
                            <td class="${isPaidOff ? 'paid-off' : ''}">${formatCurrency(balance)}</td>
                        `;
                    });
                    
                    const totalPrincipal = totalPayment - totalInterest;
                    row.innerHTML += `
                        <td class="total-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#2d3748', '#e2e8f0')}; font-weight: bold;">${formatCurrency(totalPayment)}</td>
                        <td class="total-interest-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#e53e3e', '#fc8181')};">${formatCurrency(totalInterest)}</td>
                        <td class="total-principal-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#38a169', '#68d391')};">${formatCurrency(totalPrincipal)}</td>
                        <td class="total-balance-cell" style="background: ${getThemeColor('#f7fafc', '#2d3748')}; color: ${getThemeColor('#2d3748', '#e2e8f0')}; font-weight: bold;">${formatCurrency(totalBalance)}</td>
                    `;
                });
                
                // Add collapse button if showing full schedule
                if (showFull && schedule.length > 24) {
                    const row = body.insertRow();
                    row.innerHTML = `<td colspan="100%" style="text-align: center; padding: 10px;">
                        <button onclick="updateAmortizationTable(false)" style="padding: 8px 16px;">üìä Collapse Schedule</button>
                    </td>`;
                }
                
                updateSummary(schedule);
                updatePayoffDates(schedule.debtPayoffMonths);
                
                // Auto-save state after updates
                autoSave();
                
            } catch (error) {
                console.error('Error updating amortization table:', error);
            }
        }

        function openScheduleInPopup() {
            // Create a new window with the schedule
            const popupWindow = window.open('about:blank', 'PayoffSchedule', 
                'width=1200,height=800,resizable=yes,scrollbars=yes,menubar=no,toolbar=no,location=no,status=no');
            
            if (!popupWindow) {
                alert('Please allow popups for this site to open the schedule in a new window.');
                return;
            }
            
            // Get current schedule HTML and clean it
            const header = document.getElementById('amortizationHeader').outerHTML;
            const bodyElement = document.getElementById('amortizationBody').cloneNode(true);
            
            // Remove control rows (those with buttons or pop-out icons)
            const rows = bodyElement.querySelectorAll('tr');
            rows.forEach(row => {
                if (row.innerHTML.includes('Show Simplified') || 
                    row.innerHTML.includes('Show Detailed') || 
                    row.innerHTML.includes('width: 24px; height: 24px; background:')) {
                    row.remove();
                }
            });
            
            const body = bodyElement.outerHTML;
            const currentMethodName = currentMethod.charAt(0).toUpperCase() + currentMethod.slice(1);
            
            // Build the popup HTML
            const popupHTML = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Debt Payoff Schedule - ${currentMethodName} Method</title>
                    <style>
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            margin: 20px;
                            background: #1a202c;
                            color: #e2e8f0;
                        }
                        h1 {
                            color: #e2e8f0;
                            border-bottom: 2px solid #4a5568;
                            padding-bottom: 10px;
                        }
                        table {
                            width: 100%;
                            border-collapse: collapse;
                            margin-top: 20px;
                        }
                        th, td {
                            border: 1px solid #4a5568;
                            padding: 8px;
                            text-align: left;
                        }
                        th {
                            background: #2d3748;
                            color: #e2e8f0;
                            font-weight: bold;
                        }
                        tr:nth-child(even) {
                            background: #2d3748;
                        }
                        tr:hover {
                            background: #374151;
                        }
                        .paid-off {
                            color: #68d391;
                            font-weight: bold;
                        }
                        .current-focus {
                            background: #4c51bf !important;
                            color: white;
                        }
                        .extra-in-payment {
                            color: #9f7aea;
                            font-size: 11px;
                        }
                        .total-cell {
                            font-weight: bold;
                            background: #2d3748 !important;
                            color: #e2e8f0 !important;
                        }
                        .total-interest-cell {
                            color: #fc8181;
                            background: #2d3748 !important;
                        }
                        .total-principal-cell {
                            color: #68d391;
                            background: #2d3748 !important;
                        }
                        .total-balance-cell {
                            font-weight: bold;
                            background: #2d3748 !important;
                            color: #e2e8f0 !important;
                        }
                        /* Fix all td elements to have proper text color */
                        td {
                            color: #e2e8f0;
                            background: #1a202c;
                        }
                        /* Ensure balance columns are readable */
                        td:nth-child(3n) { /* Every 3rd column (balance columns) */
                            color: #e2e8f0 !important;
                        }
                        .controls {
                            position: sticky;
                            top: 0;
                            background: #1a202c;
                            padding: 10px 0;
                            z-index: 100;
                            border-bottom: 2px solid #4a5568;
                            margin-bottom: 20px;
                        }
                        button {
                            padding: 8px 16px;
                            margin-right: 10px;
                            border-radius: 5px;
                            cursor: pointer;
                            border: none;
                            background: #4c51bf;
                            color: white;
                        }
                        button:hover {
                            background: #5a67d8;
                        }
                        .totals-subheader-cell {
                            background: #2d3748 !important;
                            color: #e2e8f0 !important;
                        }
                        /* Fix phase headers in popup */
                        td[style*="background: #4a5568"] {
                            background: #2d3748 !important;
                        }
                        td[style*="background: #22543d"],
                        td[style*="background: #2f855a"] {
                            background: #1a202c !important;
                            border: 1px solid #22543d !important;
                        }
                        @media print {
                            .controls {
                                display: none;
                            }
                            body {
                                background: white;
                                color: black;
                            }
                            th {
                                background: #f7fafc !important;
                                color: black !important;
                            }
                            tr:nth-child(even) {
                                background: #f7fafc !important;
                            }
                        }
                    </style>
                </head>
                <body>
                    <div class="controls">
                        <button onclick="window.print()">üñ®Ô∏è Print Schedule</button>
                        <button onclick="window.close()">‚ùå Close Window</button>
                        <span style="float: right; color: #a0aec0;">
                            ${currentMethodName} Method Payoff Schedule
                        </span>
                    </div>
                    <h1>Debt Payoff Schedule - ${currentMethodName} Method</h1>
                    <table>
                        <thead>
                            ${header}
                        </thead>
                        <tbody>
                            ${body}
                        </tbody>
                    </table>
                </body>
                </html>
            `;
            
            // Set the document content
            popupWindow.document.write(popupHTML);
            popupWindow.document.close();
            
            // Update the title and URL bar
            popupWindow.document.title = `Debt Payoff Schedule - ${currentMethodName} Method`;
        }
        
        function updateSimplifiedWaterfallView() {
            try {
                const schedule = calculatePayoffSchedule();
                
                if (schedule.length === 0 || currentMethod !== 'utilization') {
                    return; // Only show for waterfall method
                }
                
                const header = document.getElementById('amortizationHeader');
                const body = document.getElementById('amortizationBody');
                
                // Create simplified header
                header.innerHTML = `
                    <th>Month</th>
                    <th>Target Card(s)</th>
                    <th>Utilization Change</th>
                    <th>Payment<br><span style="font-size: 11px; font-weight: normal;">(min + extra = total)</span></th>
                    <th>Status</th>
                `;
                
                body.innerHTML = '';
                
                // Set up control row above the table
                const controlsDiv = document.getElementById('scheduleControls');
                controlsDiv.style.display = 'block';
                controlsDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button onclick="openScheduleInPopup()" style="background: transparent; 
                                border: none; cursor: pointer; padding: 0;"
                                title="Open in new window">
                            <span style="display: inline-block; width: 24px; height: 24px; background: #4c51bf; color: white; border-radius: 4px; font-size: 14px; line-height: 24px; text-align: center; font-weight: bold;">‚Üó</span>
                        </button>
                        <button onclick="updateAmortizationTable()" style="padding: 8px 16px; 
                                background: #4c51bf; color: white; border: none; 
                                border-radius: 5px; cursor: pointer;">
                            üìä Show Detailed View
                        </button>
                        <span style="color: #a0aec0; font-size: 14px;">
                            Simplified view shows only cards being actively paid down
                        </span>
                    </div>
                `;
                
                let previousPhase = null;
                let phaseStartMonth = 0;
                
                schedule.forEach((monthData, index) => {
                    // Track phase changes
                    if (monthData.phase !== previousPhase) {
                        if (previousPhase && monthData.phase) {
                            // Add phase completion row
                            const completionRow = body.insertRow();
                            completionRow.innerHTML = `
                                <td colspan="5" style="background: ${getThemeColor('#e6fffa', '#1a202c')}; color: ${getThemeColor('#22543d', '#68d391')}; 
                                         padding: 8px; text-align: center; font-weight: bold; 
                                         border: 1px solid ${getThemeColor('#38a169', '#22543d')};">
                                    ‚úÖ Complete: ${previousPhase} (${index - phaseStartMonth} months)
                                </td>
                            `;
                        }
                        
                        // Add new phase header
                        if (monthData.phase && monthData.phase !== 'Complete') {
                            const phaseRow = body.insertRow();
                            phaseRow.innerHTML = `
                                <td colspan="5" style="background: ${getThemeColor('#e6f2ff', '#1a202c')}; 
                                         color: ${getThemeColor('#2563eb', '#60a5fa')}; padding: 12px; text-align: center; font-weight: bold;">
                                    üöÄ Begin: ${monthData.phase}${getPhaseThresholdText(monthData.phase)}
                                </td>
                            `;
                            phaseStartMonth = index;
                        }
                        previousPhase = monthData.phase;
                    }
                    
                    // Find which card(s) received extra payment this month
                    const activeCards = [];
                    const creditCards = debts.filter(d => d.creditLimit && d.creditLimit > 0);
                    
                    creditCards.forEach(debt => {
                        const extraPayment = monthData.snowballAmount?.[debt.name] || 0;
                        if (extraPayment > 0) {
                            const startBalance = (monthData.balances[debt.name] || 0) + 
                                                 (monthData.payments[debt.name] || 0) - 
                                                 (monthData.interest[debt.name] || 0);
                            const endBalance = monthData.balances[debt.name] || 0;
                            
                            const startUtil = debt.creditLimit ? (startBalance / debt.creditLimit) * 100 : 0;
                            const endUtil = debt.creditLimit ? (endBalance / debt.creditLimit) * 100 : 0;
                            
                            activeCards.push({
                                name: debt.name,
                                payment: monthData.payments[debt.name] || 0,
                                minPayment: debt.minPayment || 0,
                                extraPayment: extraPayment,
                                startUtil: startUtil,
                                endUtil: endUtil,
                                utilChange: startUtil - endUtil
                            });
                        }
                    });
                    
                    // Calculate summary stats
                    const totalMinPayments = debts.reduce((sum, d) => 
                        sum + (Math.min(d.minPayment || 0, monthData.balances[d.name] || 0)), 0);
                    const totalPayments = Object.values(monthData.payments || {})
                        .reduce((sum, p) => sum + (p || 0), 0);
                    const totalExtra = totalPayments - totalMinPayments;
                    
                    // Calculate overall utilization
                    const totalCreditLimit = creditCards.reduce((sum, d) => sum + (d.creditLimit || 0), 0);
                    const totalCreditBalance = creditCards.reduce((sum, d) => 
                        sum + (monthData.balances[d.name] || 0), 0);
                    const overallUtil = totalCreditLimit > 0 ? (totalCreditBalance / totalCreditLimit) * 100 : 0;
                    
                    if (activeCards.length > 0) {
                        // Combine all active cards for this month into one row
                        const row = body.insertRow();
                        
                        // Build cards list with utilization changes
                        let cardsHTML = '';
                        let paymentsHTML = '';
                        let totalExtraForMonth = 0;
                        
                        activeCards.forEach((card, idx) => {
                            // Utilization color coding
                            let utilColor = '#38a169'; // green
                            if (card.endUtil > 89) utilColor = '#e53e3e'; // red
                            else if (card.endUtil > 49) utilColor = '#ed8936'; // orange
                            else if (card.endUtil > 29) utilColor = '#ecc94b'; // yellow
                            
                            const utilArrow = card.utilChange > 0 ? '‚Üì' : '‚Üë';
                            const utilChangeColor = card.utilChange > 0 ? '#38a169' : '#e53e3e';
                            
                            if (idx > 0) cardsHTML += '<br>';
                            cardsHTML += `<strong>${card.name}</strong>`;
                            
                            if (idx > 0) paymentsHTML += '<br>';
                            paymentsHTML += `
                                <span>${card.startUtil.toFixed(1)}%</span>
                                <span style="color: ${utilChangeColor};">‚Üí</span>
                                <span style="color: ${utilColor}; font-weight: bold;">
                                    ${card.endUtil.toFixed(1)}%
                                </span>
                                <span style="color: ${utilChangeColor}; font-size: 11px;">
                                    ${utilArrow}${Math.abs(card.utilChange).toFixed(1)}%
                                </span>
                            `;
                            
                            totalExtraForMonth += card.extraPayment;
                        });
                        
                        row.innerHTML = `
                            <td><strong>${monthData.month}</strong></td>
                            <td>${cardsHTML}</td>
                            <td>${paymentsHTML}</td>
                            <td>
                                <span style="color: ${getThemeColor('#718096', '#a0aec0')};">${formatCurrency(totalPayments - totalExtraForMonth)}</span> + 
                                <span style="color: ${getThemeColor('#667eea', '#818cf8')}; font-weight: bold;">${formatCurrency(totalExtraForMonth)}</span>
                                = <strong>${formatCurrency(totalPayments)}</strong>
                            </td>
                            <td style="font-size: 12px;">
                                <div>Util: <span style="color: ${overallUtil > 30 ? getThemeColor('#ed8936', '#f59e0b') : getThemeColor('#38a169', '#10b981')};">${overallUtil.toFixed(1)}%</span></div>
                                <div style="color: ${getThemeColor('#718096', '#a0aec0')};">Phase: ${monthData.phaseProgress || 0}%</div>
                                <div style="color: ${getThemeColor('#667eea', '#9f7aea')};">Month ${monthData.month}/${schedule.length}</div>
                            </td>
                        `;
                    } else if (monthData.month === 1 || (monthData.month % 12) === 1) {
                        // Show summary row for months with no active payments (minimums only)
                        const row = body.insertRow();
                        row.innerHTML = `
                            <td><strong>${monthData.month}</strong></td>
                            <td colspan="2" style="color: ${getThemeColor('#718096', '#9ca3af')}; font-style: italic;">
                                All cards at minimum payments
                            </td>
                            <td>Total: ${formatCurrency(totalPayments)}</td>
                            <td style="font-size: 12px;">
                                <div>Util: <span style="color: ${overallUtil > 30 ? getThemeColor('#ed8936', '#f59e0b') : getThemeColor('#38a169', '#10b981')};">${overallUtil.toFixed(1)}%</span></div>
                                <div style="color: ${getThemeColor('#667eea', '#9f7aea')};">Month ${monthData.month}/${schedule.length}</div>
                            </td>
                        `;
                    }
                });
                
                // Add final summary
                const summaryRow = body.insertRow();
                const totalMonths = schedule.length;
                const finalBalance = Object.values(schedule[schedule.length - 1].balances || {})
                    .reduce((sum, b) => sum + (b || 0), 0);
                
                summaryRow.innerHTML = `
                    <td colspan="5" style="background: #1a202c; color: #68d391; padding: 15px; text-align: center; font-weight: bold;">
                        üéâ All Debts Paid Off! Total time: ${Math.floor(totalMonths / 12)}y ${totalMonths % 12}m
                    </td>
                `;
                
            } catch (error) {
                console.error('Error updating simplified waterfall view:', error);
                updateAmortizationTable(); // Fall back to regular view
            }
        }

        function updatePayoffDates(payoffMonths) {
            const container = document.getElementById('payoffDates');
            
            // Check if payment is insufficient
            const totalMin = debts.reduce((sum, d) => sum + (d.minPayment || 0), 0);
            if (totalMonthlyPayment < totalMin || !payoffMonths || Object.keys(payoffMonths).length === 0) {
                container.innerHTML = '';
                return;
            }
            
            const sortedDebts = Object.entries(payoffMonths || {})
                .sort((a, b) => a[1] - b[1]);
            
            // Check if we should show collapsed view (more than 5 debts)
            const shouldCollapse = sortedDebts.length > 5;
            const isExpanded = container.dataset.expanded === 'true';
            
            let html = '<h4>Individual Debt Payoff Dates:</h4>';
            
            const debtsToShow = shouldCollapse && !isExpanded ? sortedDebts.slice(0, 5) : sortedDebts;
            
            debtsToShow.forEach(([debtName, month]) => {
                const date = getPayoffDate(month - 1);
                const escapedName = escapeHtml(debtName);
                html += `
                    <div class="payoff-date-item">
                        <span>${escapedName}</span>
                        <strong>${date}</strong>
                    </div>
                `;
            });
            
            if (shouldCollapse && !isExpanded) {
                html += `<div class="payoff-collapse" style="text-align: center; color: ${getThemeColor('#718096', '#9ca3af')}; font-size: 12px; margin-top: 10px; cursor: pointer; padding: 8px; background: ${getThemeColor('#f7fafc', '#1f2937')}; border-radius: 5px;" onclick="togglePayoffDates()">
                    ‚ñ∂ ... and ${sortedDebts.length - 5} more debts ... (click to expand)
                </div>`;
            } else if (shouldCollapse && isExpanded) {
                html += `<div style="text-align: center; margin-top: 10px;">
                    <button onclick="togglePayoffDates()" style="padding: 5px 10px; font-size: 12px;">‚ñº Show Less</button>
                </div>`;
            }
            
            container.innerHTML = html;
        }
        
        function togglePayoffDates() {
            const container = document.getElementById('payoffDates');
            container.dataset.expanded = container.dataset.expanded === 'true' ? 'false' : 'true';
            updatePayoffDates(calculatePayoffSchedule().debtPayoffMonths);
        }

        function updateSummary(schedule) {
            try {
                const totalDebt = debts.reduce((sum, d) => sum + (d.balance || 0), 0);
                const totalMin = debts.reduce((sum, d) => sum + (d.minPayment || 0), 0);
                
                // Check if payment is insufficient
                if (totalMonthlyPayment < totalMin || schedule.length === 0) {
                    const summaryDiv = document.getElementById('summary');
                    summaryDiv.innerHTML = `
                        <div style="background: ${getThemeColor('#fed7d7', '#2d1a1a')}; padding: 20px; border-radius: 8px; text-align: center;">
                            <div style="color: ${getThemeColor('#c53030', '#f87171')}; font-size: 20px; font-weight: bold; margin-bottom: 10px;">
                                ‚ö†Ô∏è INSUFFICIENT PAYMENT
                            </div>
                            <div style="color: ${getThemeColor('#742a2a', '#fca5a5')}; margin-bottom: 10px;">
                                Your monthly payment of ${formatCurrency(totalMonthlyPayment)} is less than the 
                                required minimum of ${formatCurrency(totalMin)}
                            </div>
                            <div style="color: ${getThemeColor('#742a2a', '#fca5a5')}; font-weight: bold;">
                                Please increase your Total Monthly Payment to at least ${formatCurrency(totalMin)}
                            </div>
                        </div>
                    `;
                    return;
                }
                
                const totalInterest = schedule.reduce((sum, month) => {
                    return sum + Object.values(month.interest || {}).reduce((s, i) => s + (i || 0), 0);
                }, 0);
                const totalPaid = totalDebt + totalInterest;
                const months = schedule.length;
                const years = Math.floor(months / 12);
                const remainingMonths = months % 12;
                
                const finalDate = getPayoffDate(months);
                
                // Get current phase information if using waterfall method
                let phaseHTML = '';
                if (currentMethod === 'utilization' && schedule.length > 0) {
                    const firstMonth = schedule[0];
                    if (firstMonth.phase) {
                        const phaseInfo = firstMonth.phase;
                        const progressBar = firstMonth.phaseProgress ? `
                            <div style="background: #e2e8f0; border-radius: 10px; height: 8px; margin-top: 5px; overflow: hidden;">
                                <div style="background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); 
                                           height: 100%; width: ${firstMonth.phaseProgress}%; 
                                           transition: width 0.3s ease;"></div>
                            </div>
                            <div style="font-size: 11px; color: #718096; margin-top: 3px;">
                                Progress: ${firstMonth.phaseProgress}%
                            </div>
                        ` : '';
                        
                        phaseHTML = `
                            <div class="summary-item" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                                              color: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <div class="summary-label" style="color: #e0e7ff; font-size: 12px; margin-bottom: 5px;">
                                    Waterfall Phase
                                </div>
                                <div class="summary-value" style="color: white; font-size: 16px; font-weight: bold;">
                                    ${phaseInfo}
                                </div>
                                ${progressBar}
                            </div>
                        `;
                    }
                }
                
                const summaryDiv = document.getElementById('summary');
                summaryDiv.innerHTML = `
                    ${phaseHTML}
                    <div class="summary-item">
                        <div class="summary-label">Total Debt</div>
                        <div class="summary-value">${formatCurrency(totalDebt)}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total Interest</div>
                        <div class="summary-value">${formatCurrency(totalInterest)}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Total to Pay</div>
                        <div class="summary-value">${formatCurrency(totalPaid)}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Time to Freedom</div>
                        <div class="summary-value">${years}y ${remainingMonths}m</div>
                        <div class="summary-date">Free by: ${finalDate}</div>
                    </div>
                    <div class="summary-item">
                        <div class="summary-label">Method</div>
                        <div class="summary-value" style="font-size: 18px;">${currentMethod.toUpperCase()}</div>
                    </div>
                `;
            } catch (error) {
                console.error('Error updating summary:', error);
            }
        }

        function showComparison() {
            try {
                const methods = ['snowball', 'avalanche', 'cfi', 'utilization', 'custom'];
                const results = {};
                
                // Calculate baseline (minimums only)
                const originalPayment = totalMonthlyPayment;
                const totalMin = debts.reduce((sum, d) => sum + (d.minPayment || 0), 0);
                
                // Calculate with minimums only
                totalMonthlyPayment = totalMin;
                const baselineSchedule = calculatePayoffSchedule(null, 'avalanche');
                const baselineInterest = baselineSchedule.reduce((sum, month) => {
                    return sum + Object.values(month.interest || {}).reduce((s, i) => s + (i || 0), 0);
                }, 0);
                const baselineMonths = baselineSchedule.length;
                
                // Restore original payment
                totalMonthlyPayment = originalPayment;
                
                methods.forEach(method => {
                    const debtsCopy = JSON.parse(JSON.stringify(debts));
                    const schedule = calculatePayoffSchedule(debtsCopy, method);
                    
                    if (schedule.length > 0) {
                        const totalInterest = schedule.reduce((sum, month) => {
                            return sum + Object.values(month.interest || {}).reduce((s, i) => s + (i || 0), 0);
                        }, 0);
                        
                        results[method] = {
                            months: schedule.length,
                            totalInterest: totalInterest,
                            totalPaid: debts.reduce((sum, d) => sum + (d.balance || 0), 0) + totalInterest,
                            interestSaved: baselineInterest - totalInterest,
                            monthsSaved: baselineMonths - schedule.length
                        };
                    }
                });
                
                const validResults = Object.entries(results).filter(([k, v]) => v.totalInterest > 0);
                if (validResults.length === 0) {
                    showError('Unable to calculate comparison. Please check your inputs.');
                    return;
                }
                
                // Find best methods
                const bestInterest = Math.min(...validResults.map(([k, v]) => v.totalInterest));
                const bestTime = Math.min(...validResults.map(([k, v]) => v.months));
                
                const comparisonDiv = document.getElementById('comparisonResults');
                comparisonDiv.innerHTML = '';
                
                // Add baseline card
                if (baselineMonths > 0) {
                    const baselineYears = Math.floor(baselineMonths / 12);
                    const baselineRemMonths = baselineMonths % 12;
                    const baselineDate = getPayoffDate(baselineMonths);
                    
                    comparisonDiv.innerHTML += `
                        <div class="comparison-card baseline" style="background: ${getThemeColor('#f1f5f9', '#0b1220')}; border-color: ${getThemeColor('#94a3b8', '#1f2937')};">
                            <div class="comparison-title">üìä Baseline (Minimums Only)</div>
                            <div class="comparison-stat">
                                <span>Time:</span>
                                <strong>${baselineYears}y ${baselineRemMonths}m</strong>
                            </div>
                            <div class="comparison-stat">
                                <span>Paid off by:</span>
                                <strong>${baselineDate}</strong>
                            </div>
                            <div class="comparison-stat">
                                <span>Total Interest:</span>
                                <strong>${formatCurrency(baselineInterest)}</strong>
                            </div>
                            <div class="comparison-stat">
                                <span>Total Paid:</span>
                                <strong>${formatCurrency(debts.reduce((sum, d) => sum + d.balance, 0) + baselineInterest)}</strong>
                            </div>
                            <div class="comparison-feature" style="color: #64748b;">Reference Point</div>
                            <div style="text-align: center; font-size: 11px; color: #94a3b8; margin-top: 5px;">
                                No extra payments applied
                            </div>
                        </div>
                    `;
                }
                
                const methodInfo = {
                    snowball: {
                        name: '‚ùÑÔ∏è Snowball',
                        benefit: 'Quick psychological wins',
                        description: 'Pays smallest debts first for motivation'
                    },
                    avalanche: {
                        name: 'üèîÔ∏è Avalanche', 
                        benefit: 'Mathematically optimal',
                        description: 'Targets highest interest rates first'
                    },
                    cfi: {
                        name: 'üí∏ Cash Flow Index',
                        benefit: 'Improves monthly cash flow',
                        description: 'Best ratio of balance to payment'
                    },
                    utilization: {
                        name: 'üìà Credit Score',
                        benefit: 'Improves credit score',
                        description: 'Reduces high utilization cards first'
                    },
                    custom: {
                        name: 'üéØ Custom',
                        benefit: 'Your personalized order',
                        description: 'Based on your priorities'
                    }
                };
                
                Object.entries(results).forEach(([method, data]) => {
                    const isBestInterest = Math.abs(data.totalInterest - bestInterest) < 1;
                    const isBestTime = data.months === bestTime;
                    const years = Math.floor(data.months / 12);
                    const months = data.months % 12;
                    const payoffDate = getPayoffDate(data.months);
                    
                    let cardClass = 'comparison-card';
                    const isCurrentMethod = method === currentMethod;
                    
                    if (isCurrentMethod) {
                        cardClass += ' current-method';
                    } else if (isBestInterest && !isBestTime) {
                        cardClass += ' best-interest';
                    } else if (isBestTime && !isBestInterest) {
                        cardClass += ' best-time';
                    } else if (isBestInterest && isBestTime) {
                        cardClass += ' best-interest best-time';
                    }
                    
                    // Time Saved/Lost row is always shown for consistency
                    const diff = data.monthsSaved || 0;
                    const diffYears = Math.floor(Math.abs(diff) / 12);
                    const diffMonths = Math.abs(diff) % 12;
                    const timeLabel = diff < 0 ? 'Time Lost' : 'Time Saved';
                    const timeColor = diff < 0 ? '#e11d48' : (diff > 0 ? '#0891b2' : '#718096');
                    const timeRow = `
                            <div class="comparison-stat" style="color: ${timeColor};">
                                <span>${timeLabel}:</span>
                                <strong>${diffYears}y ${diffMonths}m</strong>
                            </div>`;
                    
                    comparisonDiv.innerHTML += `
                        <div class="${cardClass}" onclick="selectMethodFromComparison('${method}')">
                            <div class="comparison-title">${methodInfo[method].name}</div>
                            ${isCurrentMethod ? '<div style="text-align: center; color: #667eea; font-weight: bold; font-size: 11px; margin-bottom: 5px;">‚úì CURRENT METHOD</div>' : ''}
                            <div class="comparison-stat">
                                <span>Time:</span>
                                <strong>${years}y ${months}m</strong>
                            </div>
                            <div class="comparison-stat">
                                <span>Paid off by:</span>
                                <strong>${payoffDate}</strong>
                            </div>
                            <div class="comparison-stat">
                                <span>Total Interest:</span>
                                <strong>${formatCurrency(data.totalInterest)}</strong>
                            </div>
                            <div class="comparison-stat">
                                <span>Total Paid:</span>
                                <strong>${formatCurrency(data.totalPaid)}</strong>
                            </div>
                            ${data.interestSaved > 0 ? `
                            <div class="comparison-stat" style="color: #059669;">
                                <span>Interest Saved:</span>
                                <strong>${formatCurrency(data.interestSaved)}</strong>
                            </div>` : ''}
                            ${timeRow}
                            <div class="comparison-feature" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #e2e8f0;">
                                ${methodInfo[method].benefit}
                            </div>
                            <div style="text-align: center; font-size: 11px; color: #718096; margin-top: 5px;">
                                ${methodInfo[method].description}
                            </div>
                            <div style="margin-top: 10px; text-align: center;">
                                ${isBestInterest && !isBestTime ? '<span class="comparison-badge badge-money">üí∞ Saves Most Money</span>' : ''}
                                ${isBestTime && !isBestInterest ? '<span class="comparison-badge badge-time">‚è±Ô∏è Fastest Payoff</span>' : ''}
                                ${isBestInterest && isBestTime ? '<span class="comparison-badge badge-money">üí∞ Best Overall</span>' : ''}
                            </div>
                        </div>
                    `;
                });
                
                document.getElementById('comparisonModal').classList.add('show');
            } catch (error) {
                console.error('Error showing comparison:', error);
                showError('Error generating comparison. Please check your inputs.');
            }
        }
        
        function selectMethodFromComparison(method) {
            setMethod(method);
            // Don't close modal - just update the display
            showComparison();
        }
        
        // Add click-outside-to-close for modal
        document.addEventListener('DOMContentLoaded', function() {
            const modal = document.getElementById('comparisonModal');
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeModal();
                }
            });
            // Sticky info-tooltips: click to toggle, click-outside to close
            document.querySelectorAll('.info-tooltip').forEach(el => {
                el.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    el.classList.toggle('sticky');
                });
            });
            document.addEventListener('click', () => {
                document.querySelectorAll('.info-tooltip.sticky').forEach(el => el.classList.remove('sticky'));
            });
            // Restore app state
            restoreFromLocalStorage();
        });

        function closeModal() {
            document.getElementById('comparisonModal').classList.remove('show');
        }

        // Theme: light/dark persistence and toggle
        (function initTheme() {
            try {
                const saved = localStorage.getItem('theme');
                if (saved === 'dark') {
                    document.body.classList.add('dark');
                }
                document.addEventListener('DOMContentLoaded', function() {
                    const btn = document.getElementById('themeToggle');
                    if (!btn) return;
                    const updateLabel = () => {
                        const isDark = document.body.classList.contains('dark');
                        btn.textContent = isDark ? '‚òÄÔ∏è Light' : 'üåô Dark';
                    };
                    updateLabel();
                    btn.addEventListener('click', function() {
                        document.body.classList.toggle('dark');
                        const isDark = document.body.classList.contains('dark');
                        localStorage.setItem('theme', isDark ? 'dark' : 'light');
                        updateLabel();
                    });
                });
            } catch (e) {
                console.warn('Theme init failed', e);
            }
        })();

        function updateSyncButtonState() {
            try {
                const btn = document.getElementById('syncCustomBtn');
                const label = document.getElementById('syncMethodLabel');
                if (!btn || !label) return;
                const pretty = currentMethod.toUpperCase();
                label.textContent = pretty;
                // disable if already custom and orders match
                const isCustom = currentMethod === 'custom';
                const sorted = [...debts];
                sortDebtsCopy(sorted, isCustom ? 'custom' : currentMethod);
                const ordersMatch = sorted.every((d, idx) => d.id === debts[idx].id);
                btn.disabled = isCustom && ordersMatch;
            } catch (e) {
                console.warn('updateSyncButtonState failed', e);
            }
        }

        function syncCustomOrderToCurrentMethod() {
            try {
                const methodToSync = currentMethod;
                const sorted = [...debts];
                sortDebtsCopy(sorted, methodToSync);
                // Apply sorted order to the actual debts array
                debts = sorted.map((d, i) => ({ ...d, customOrder: i + 1 }));
                // Switch to custom without re-sorting
                setMethod('custom', true);
                updateDebtTable();
                updateAmortizationTable();
                updateSyncButtonState();
                persistToLocalStorage();
            } catch (e) {
                console.error('Failed to sync custom order:', e);
                showError('Failed to sync custom order.');
            }
        }

        function exportToCSV() {
            try {
                const schedule = calculatePayoffSchedule();
                
                if (schedule.length === 0) {
                    showError('No schedule to export. Please check your inputs.');
                    return;
                }
                
                let csv = 'Month,Date,Extra Payment';
                
                debts.forEach(debt => {
                    const escapedName = debt.name.replace(/"/g, '""');
                    csv += `,"${escapedName} Payment","${escapedName} Snowball","${escapedName} Interest","${escapedName} Balance"`;
                });
                csv += ',Total Payment,Total Interest,Total Principal,Total Balance\n';
                
                schedule.forEach(month => {
                    const monthDate = getPayoffDate(month.month - 1);
                    csv += `${month.month},${monthDate},${month.extra || 0}`;
                    
                    let totalPayment = 0;
                    let totalInterest = 0;
                    let totalBalance = 0;
                    
                    debts.forEach(debt => {
                        const payment = month.payments[debt.name] || 0;
                        const snowball = month.snowballAmount[debt.name] || 0;
                        const interest = month.interest[debt.name] || 0;
                        const balance = month.balances[debt.name] || 0;
                        
                        totalPayment += payment;
                        totalInterest += interest;
                        totalBalance += balance;
                        
                        csv += `,${payment.toFixed(2)},${snowball.toFixed(2)},${interest.toFixed(2)},${balance.toFixed(2)}`;
                    });
                    
                    const totalPrincipal = totalPayment - totalInterest;
                    csv += `,${totalPayment.toFixed(2)},${totalInterest.toFixed(2)},${totalPrincipal.toFixed(2)},${totalBalance.toFixed(2)}`;
                    csv += '\n';
                });
                
                downloadCSV(csv, 'debt_payoff_schedule.csv');
            } catch (error) {
                console.error('Error exporting to CSV:', error);
                showError('Error exporting to CSV.');
            }
        }

        function exportSimplifiedToCSV() {
            try {
                const schedule = calculatePayoffSchedule();

                if (schedule.length === 0) {
                    showError('No schedule to export. Please check your inputs.');
                    return;
                }

                // Create simplified CSV with essential columns only
                const methodInfo = {
                    snowball: { name: '‚ùÑÔ∏è Snowball' },
                    avalanche: { name: 'üèîÔ∏è Avalanche' },
                    cfi: { name: 'üí∏ Cash Flow' },
                    utilization: { name: 'üìà Credit Score' },
                    custom: { name: 'üéØ Custom' }
                };

                const methodName = methodInfo[currentMethod]?.name || currentMethod.toUpperCase();

                let csv = 'Month,Date,Total Payment,Snowball Amount,Extra Payment,Interest Paid,Total Balance,Milestones\n';

                // Track running totals for summary
                let totalInterestPaid = 0;
                let totalExtraPaid = 0;
                let totalSnowballPaid = 0;

                schedule.forEach(month => {
                    const monthDate = getPayoffDate(month.month - 1);

                    // Calculate totals for this month
                    let totalPayment = 0;
                    let totalSnowball = 0;
                    let totalInterest = 0;
                    let totalBalance = 0;
                    let milestones = [];

                    debts.forEach(debt => {
                        const payment = month.payments[debt.name] || 0;
                        const snowball = month.snowballAmount[debt.name] || 0;
                        const interest = month.interest[debt.name] || 0;
                        const balance = month.balances[debt.name] || 0;

                        totalPayment += payment;
                        totalSnowball += snowball;
                        totalInterest += interest;
                        totalBalance += balance;

                        // Check for payoff milestones
                        const previousBalance = month.month > 1 ?
                            (schedule[month.month - 2]?.balances[debt.name] || 0) : debt.balance;

                        if (previousBalance > 0 && balance === 0) {
                            milestones.push(`${debt.name} paid off`);
                        }
                    });

                    let milestoneText = milestones.join('; ');

                    // Add total accounts count to first row
                    if (month.month === 1) {
                        const accountsText = `${debts.length} accounts total`;
                        milestoneText = milestoneText ?
                            `${accountsText}; ${milestoneText}` :
                            accountsText;
                    }

                    // Check if this is the final month (all debts paid off)
                    const isFinalMonth = totalBalance === 0;
                    if (isFinalMonth) {
                        const finalText = 'All debts paid off!';
                        milestoneText = milestoneText ?
                            `${milestoneText}; ${finalText}` :
                            finalText;
                    }

                    const extraPayment = month.extra || 0;

                    // Accumulate running totals
                    totalInterestPaid += totalInterest;
                    totalExtraPaid += extraPayment;
                    totalSnowballPaid += totalSnowball;

                    csv += `${month.month},"${monthDate}",${totalPayment.toFixed(2)},${totalSnowball.toFixed(2)},${extraPayment.toFixed(2)},${totalInterest.toFixed(2)},${totalBalance.toFixed(2)},"${milestoneText}"\n`;
                });

                // Add summary row with method info in milestones column
                csv += `,"TOTALS",,${totalSnowballPaid.toFixed(2)},${totalExtraPaid.toFixed(2)},${totalInterestPaid.toFixed(2)},,"Payoff Method Used: ${methodName}"\n`;

                downloadCSV(csv, 'debt_payoff_schedule_simple.csv');
            } catch (error) {
                console.error('Error exporting simplified CSV:', error);
                showError('Error exporting simplified CSV.');
            }
        }

        function exportDebtListToCSV() {
            try {
                let csv = 'Order,Name,Type,Balance,Interest Rate,Min Payment,Credit Limit,Utilization,Monthly Interest,CFI\n';
                
                debts.forEach((debt, index) => {
                    const monthlyInterest = calculateMonthlyInterest(debt.balance, debt.rate);
                    const cfi = calculateCFI(debt.balance, debt.minPayment, debt.rate);
                    const utilization = calculateUtilization(debt.balance, debt.creditLimit);
                    
                    csv += `${index + 1},"${debt.name}",${debt.type || 'credit'},${debt.balance},${debt.rate},${debt.minPayment},${debt.creditLimit || ''},${utilization ? utilization.toFixed(2) : ''},${monthlyInterest.toFixed(2)},${cfi === Infinity ? 'Infinity' : cfi.toFixed(2)}\n`;
                });
                
                downloadCSV(csv, 'debt_list.csv');
            } catch (error) {
                console.error('Error exporting debt list:', error);
                showError('Error exporting debt list.');
            }
        }

        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #48bb78; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; animation: slideIn 0.3s ease;';
            successMsg.textContent = `‚úì ${filename} downloaded successfully`;
            document.body.appendChild(successMsg);
            setTimeout(() => document.body.removeChild(successMsg), 3000);
        }

        function autoSave() {
            try {
                const payload = {
                    debts: debts,
                    extraPayments: extraPayments,
                    totalMonthlyPayment: totalMonthlyPayment,
                    currentMethod: currentMethod,
                    startDate: document.getElementById('startDate').value,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('adc_state', JSON.stringify(payload));
            } catch (e) {
                console.warn('Auto-save failed', e);
            }
        }
        
        function saveConfiguration() {
            try {
                const config = {
                    debts: debts,
                    extraPayments: extraPayments,
                    totalMonthlyPayment: totalMonthlyPayment,
                    currentMethod: currentMethod,
                    startDate: document.getElementById('startDate').value,
                    customOrder: debts.map(d => ({ id: d.id, order: d.customOrder })),
                    version: 1
                };
                
                const json = JSON.stringify(config, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'debt_config.json');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error saving configuration:', error);
                showError('Error saving configuration.');
            }
        }

        function copyConfigurationJSON() {
            try {
                const data = {
                    debts,
                    extraPayments,
                    totalMonthlyPayment,
                    currentMethod,
                    startDate: document.getElementById('startDate').value,
                    version: 1
                };
                const json = JSON.stringify(data, null, 2);
                navigator.clipboard.writeText(json).then(() => {
                    const msg = document.createElement('div');
                    msg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4b5563; color: white; padding: 10px 14px; border-radius: 6px; z-index: 10000;';
                    msg.textContent = '‚úì Configuration copied to clipboard';
                    document.body.appendChild(msg);
                    setTimeout(() => document.body.removeChild(msg), 2000);
                });
            } catch (e) {
                console.error('Copy JSON failed', e);
            }
        }

        function loadConfiguration() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,application/json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const config = JSON.parse(event.target.result);
                        debts = config.debts || debts;
                        extraPayments = config.extraPayments || [];
                        totalMonthlyPayment = config.totalMonthlyPayment || 3000;
                        currentMethod = config.currentMethod || 'snowball';
                        
                        // Restore custom order if available
                        if (config.customOrder) {
                            config.customOrder.forEach(order => {
                                const debt = debts.find(d => d.id === order.id);
                                if (debt) {
                                    debt.customOrder = order.order;
                                }
                            });
                        }
                        
                        // Ensure type field exists
                        debts.forEach(debt => {
                            if (!debt.type) {
                                debt.type = debt.creditLimit ? 'credit' : 'loan';
                            }
                            if (!debt.customOrder) {
                                debt.customOrder = 999;
                            }
                        });
                        
                        if (config.startDate) {
                            document.getElementById('startDate').value = config.startDate;
                        }
                        
                        debts.forEach((debt, index) => {
                            if (!debt.id) {
                                debt.id = index + 1;
                            }
                        });
                        nextDebtId = Math.max(...debts.map(d => d.id)) + 1;
                        
                        document.getElementById('totalMonthly').value = totalMonthlyPayment;
                        setMethod(currentMethod);
                        persistToLocalStorage();
                        
                        const container = document.getElementById('extraPaymentsList');
                        container.innerHTML = '';
                        if (extraPayments.length === 0) {
                            addExtraPayment();
                        } else {
                            extraPayments.forEach(payment => {
                                addExtraPayment(payment);
                            });
                        }
                        
                        updateDebtTable();
                        updateAmortizationTable();
                        
                        // Show success message
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #48bb78; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000;';
                        successMsg.textContent = '‚úì Configuration loaded successfully';
                        document.body.appendChild(successMsg);
                        setTimeout(() => document.body.removeChild(successMsg), 3000);
                    } catch (err) {
                        console.error('Error loading configuration:', err);
                        showError('Error loading configuration: ' + err.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function persistToLocalStorage() {
            try {
                const payload = {
                    v: 1,
                    debts,
                    extraPayments,
                    totalMonthlyPayment,
                    currentMethod,
                    startDate: document.getElementById('startDate').value
                };
                localStorage.setItem('adc_state', JSON.stringify(payload));
            } catch (e) {
                console.warn('Persist failed', e);
            }
        }

        function restoreFromLocalStorage() {
            try {
                const raw = localStorage.getItem('adc_state');
                if (!raw) return;
                const s = JSON.parse(raw);
                if (!s || typeof s !== 'object') return;
                debts = s.debts || debts;
                extraPayments = s.extraPayments || extraPayments;
                totalMonthlyPayment = s.totalMonthlyPayment || totalMonthlyPayment;
                currentMethod = s.currentMethod || currentMethod;
                if (s.startDate) document.getElementById('startDate').value = s.startDate;
                document.getElementById('totalMonthly').value = totalMonthlyPayment;
                setMethod(currentMethod);
                // rebuild extra payments UI
                const container = document.getElementById('extraPaymentsList');
                container.innerHTML = '';
                if (extraPayments.length === 0) addExtraPayment();
                else extraPayments.forEach(p => addExtraPayment(p));
                updateDebtTable();
                updateAmortizationTable();
            } catch (e) {
                console.warn('Restore failed', e);
            }
        }

        function resetAll() {
            if (!confirm('Reset all data and clear storage?')) return;
            localStorage.removeItem('adc_state');
            // Restore to basic defaults
            debts = [];
            nextDebtId = 1;
            addDebt();
            extraPayments = [];
            const list = document.getElementById('extraPaymentsList');
            if (list) { list.innerHTML = ''; addExtraPayment(); }
            totalMonthlyPayment = 3000;
            document.getElementById('totalMonthly').value = totalMonthlyPayment;
            document.getElementById('startDate').value = '';
            setMethod('snowball');
            updateDebtTable();
            updateAmortizationTable();
            persistToLocalStorage();
        }

        // Event listeners
        document.getElementById('totalMonthly').addEventListener('blur', (e) => {
            totalMonthlyPayment = parseFloat(e.target.value) || 0;
            updateDebtTable();
            updateAmortizationTable();
        });

        // Initialize
        initializeStartDate();
        
        // Auto-load saved configuration if available
        try {
            const savedState = localStorage.getItem('adc_state');
            if (savedState) {
                const state = JSON.parse(savedState);
                if (state && state.debts && state.debts.length > 0) {
                    // Restore saved state
                    debts = state.debts || [];
                    extraPayments = state.extraPayments || [];
                    totalMonthlyPayment = state.totalMonthlyPayment || 5000;
                    currentMethod = state.currentMethod || 'snowball';
                    if (state.startDate) {
                        document.getElementById('startDate').value = state.startDate;
                    }
                    document.getElementById('totalMonthly').value = totalMonthlyPayment;
                    
                    // Reconstruct debt IDs
                    nextDebtId = Math.max(...debts.map(d => d.id || 0), 0) + 1;
                    
                    // Update UI
                    setMethod(currentMethod);
                    updateDebtTable();
                    updateExtraPaymentsTable();
                    updateAmortizationTable();
                    
                    console.log('Auto-loaded saved configuration');
                } else {
                    // No saved data, start with defaults
                    addExtraPayment();
                    updateDebtTable();
                    updateAmortizationTable();
                }
            } else {
                // No saved data, start with defaults
                addExtraPayment();
                updateDebtTable();
                updateAmortizationTable();
            }
        } catch (e) {
            console.warn('Failed to auto-load saved state:', e);
            // Fall back to defaults
            addExtraPayment();
            updateDebtTable();
            updateAmortizationTable();
        }
    </script>
</body>
</html>